/*This is an auto-generated file generated by exporterrors. Do not modify it.*/

#ifndef KDBERRORS_H
#define KDBERRORS_H

#include <kdb.h>
#include <kdbhelper.h>
#include <kdblogger.h>
#include <kdbmacros.h>
#include <string.h>

#ifdef __cplusplus
using namespace ckdb;
#endif


#define ELEKTRA_SET_RESOURCE_ERROR(key, text) \
	do { ELEKTRA_LOG ("Add Error C01100: %s", text); elektraSetErrorC01100(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME)); } while (0)
#define ELEKTRA_SET_RESOURCE_ERRORF(key, text, ...) \
	do { ELEKTRA_LOG ("Add Error C01100: " text, __VA_ARGS__); elektraSetErrorfC01100(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME), __VA_ARGS__); } while (0)
#define ELEKTRA_ADD_RESOURCE_WARNING(key, text) \
	do { ELEKTRA_LOG ("Add Warning C01100: %s", text); elektraAddWarningC01100(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME)); } while (0)
#define ELEKTRA_ADD_RESOURCE_WARNINGF(key, text, ...) \
	do { ELEKTRA_LOG ("Add Warning C01100: " text, __VA_ARGS__); elektraAddWarningfC01100(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME), __VA_ARGS__); } while (0)

#define ELEKTRA_SET_OUT_OF_MEMORY_ERROR(key, text) \
	do { ELEKTRA_LOG ("Add Error C01110: %s", text); elektraSetErrorC01110(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME)); } while (0)
#define ELEKTRA_SET_OUT_OF_MEMORY_ERRORF(key, text, ...) \
	do { ELEKTRA_LOG ("Add Error C01110: " text, __VA_ARGS__); elektraSetErrorfC01110(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME), __VA_ARGS__); } while (0)
#define ELEKTRA_ADD_OUT_OF_MEMORY_WARNING(key, text) \
	do { ELEKTRA_LOG ("Add Warning C01110: %s", text); elektraAddWarningC01110(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME)); } while (0)
#define ELEKTRA_ADD_OUT_OF_MEMORY_WARNINGF(key, text, ...) \
	do { ELEKTRA_LOG ("Add Warning C01110: " text, __VA_ARGS__); elektraAddWarningfC01110(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME), __VA_ARGS__); } while (0)

#define ELEKTRA_SET_INSTALLATION_ERROR(key, text) \
	do { ELEKTRA_LOG ("Add Error C01200: %s", text); elektraSetErrorC01200(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME)); } while (0)
#define ELEKTRA_SET_INSTALLATION_ERRORF(key, text, ...) \
	do { ELEKTRA_LOG ("Add Error C01200: " text, __VA_ARGS__); elektraSetErrorfC01200(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME), __VA_ARGS__); } while (0)
#define ELEKTRA_ADD_INSTALLATION_WARNING(key, text) \
	do { ELEKTRA_LOG ("Add Warning C01200: %s", text); elektraAddWarningC01200(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME)); } while (0)
#define ELEKTRA_ADD_INSTALLATION_WARNINGF(key, text, ...) \
	do { ELEKTRA_LOG ("Add Warning C01200: " text, __VA_ARGS__); elektraAddWarningfC01200(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME), __VA_ARGS__); } while (0)

#define ELEKTRA_SET_INTERNAL_ERROR(key, text) \
	do { ELEKTRA_LOG ("Add Error C01310: %s", text); elektraSetErrorC01310(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME)); } while (0)
#define ELEKTRA_SET_INTERNAL_ERRORF(key, text, ...) \
	do { ELEKTRA_LOG ("Add Error C01310: " text, __VA_ARGS__); elektraSetErrorfC01310(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME), __VA_ARGS__); } while (0)
#define ELEKTRA_ADD_INTERNAL_WARNING(key, text) \
	do { ELEKTRA_LOG ("Add Warning C01310: %s", text); elektraAddWarningC01310(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME)); } while (0)
#define ELEKTRA_ADD_INTERNAL_WARNINGF(key, text, ...) \
	do { ELEKTRA_LOG ("Add Warning C01310: " text, __VA_ARGS__); elektraAddWarningfC01310(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME), __VA_ARGS__); } while (0)

#define ELEKTRA_SET_INTERFACE_ERROR(key, text) \
	do { ELEKTRA_LOG ("Add Error C01320: %s", text); elektraSetErrorC01320(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME)); } while (0)
#define ELEKTRA_SET_INTERFACE_ERRORF(key, text, ...) \
	do { ELEKTRA_LOG ("Add Error C01320: " text, __VA_ARGS__); elektraSetErrorfC01320(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME), __VA_ARGS__); } while (0)
#define ELEKTRA_ADD_INTERFACE_WARNING(key, text) \
	do { ELEKTRA_LOG ("Add Warning C01320: %s", text); elektraAddWarningC01320(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME)); } while (0)
#define ELEKTRA_ADD_INTERFACE_WARNINGF(key, text, ...) \
	do { ELEKTRA_LOG ("Add Warning C01320: " text, __VA_ARGS__); elektraAddWarningfC01320(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME), __VA_ARGS__); } while (0)

#define ELEKTRA_SET_PLUGIN_MISBEHAVIOR_ERROR(key, text) \
	do { ELEKTRA_LOG ("Add Error C01330: %s", text); elektraSetErrorC01330(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME)); } while (0)
#define ELEKTRA_SET_PLUGIN_MISBEHAVIOR_ERRORF(key, text, ...) \
	do { ELEKTRA_LOG ("Add Error C01330: " text, __VA_ARGS__); elektraSetErrorfC01330(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME), __VA_ARGS__); } while (0)
#define ELEKTRA_ADD_PLUGIN_MISBEHAVIOR_WARNING(key, text) \
	do { ELEKTRA_LOG ("Add Warning C01330: %s", text); elektraAddWarningC01330(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME)); } while (0)
#define ELEKTRA_ADD_PLUGIN_MISBEHAVIOR_WARNINGF(key, text, ...) \
	do { ELEKTRA_LOG ("Add Warning C01330: " text, __VA_ARGS__); elektraAddWarningfC01330(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME), __VA_ARGS__); } while (0)

#define ELEKTRA_SET_CONFLICTING_STATE_ERROR(key, text) \
	do { ELEKTRA_LOG ("Add Error C02000: %s", text); elektraSetErrorC02000(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME)); } while (0)
#define ELEKTRA_SET_CONFLICTING_STATE_ERRORF(key, text, ...) \
	do { ELEKTRA_LOG ("Add Error C02000: " text, __VA_ARGS__); elektraSetErrorfC02000(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME), __VA_ARGS__); } while (0)
#define ELEKTRA_ADD_CONFLICTING_STATE_WARNING(key, text) \
	do { ELEKTRA_LOG ("Add Warning C02000: %s", text); elektraAddWarningC02000(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME)); } while (0)
#define ELEKTRA_ADD_CONFLICTING_STATE_WARNINGF(key, text, ...) \
	do { ELEKTRA_LOG ("Add Warning C02000: " text, __VA_ARGS__); elektraAddWarningfC02000(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME), __VA_ARGS__); } while (0)

#define ELEKTRA_SET_VALIDATION_SYNTACTIC_ERROR(key, text) \
	do { ELEKTRA_LOG ("Add Error C03100: %s", text); elektraSetErrorC03100(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME)); } while (0)
#define ELEKTRA_SET_VALIDATION_SYNTACTIC_ERRORF(key, text, ...) \
	do { ELEKTRA_LOG ("Add Error C03100: " text, __VA_ARGS__); elektraSetErrorfC03100(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME), __VA_ARGS__); } while (0)
#define ELEKTRA_ADD_VALIDATION_SYNTACTIC_WARNING(key, text) \
	do { ELEKTRA_LOG ("Add Warning C03100: %s", text); elektraAddWarningC03100(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME)); } while (0)
#define ELEKTRA_ADD_VALIDATION_SYNTACTIC_WARNINGF(key, text, ...) \
	do { ELEKTRA_LOG ("Add Warning C03100: " text, __VA_ARGS__); elektraAddWarningfC03100(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME), __VA_ARGS__); } while (0)

#define ELEKTRA_SET_VALIDATION_SEMANTIC_ERROR(key, text) \
	do { ELEKTRA_LOG ("Add Error C03200: %s", text); elektraSetErrorC03200(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME)); } while (0)
#define ELEKTRA_SET_VALIDATION_SEMANTIC_ERRORF(key, text, ...) \
	do { ELEKTRA_LOG ("Add Error C03200: " text, __VA_ARGS__); elektraSetErrorfC03200(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME), __VA_ARGS__); } while (0)
#define ELEKTRA_ADD_VALIDATION_SEMANTIC_WARNING(key, text) \
	do { ELEKTRA_LOG ("Add Warning C03200: %s", text); elektraAddWarningC03200(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME)); } while (0)
#define ELEKTRA_ADD_VALIDATION_SEMANTIC_WARNINGF(key, text, ...) \
	do { ELEKTRA_LOG ("Add Warning C03200: " text, __VA_ARGS__); elektraAddWarningfC03200(key, text, __FILE__, ELEKTRA_STRINGIFY(__LINE__), ELEKTRA_STRINGIFY(ELEKTRA_MODULE_NAME), __VA_ARGS__); } while (0)


#define ELEKTRA_WARNING_RESOURCE "C01100"
#define ELEKTRA_ERROR_RESOURCE "C01100"
#define ELEKTRA_WARNING_OUT_OF_MEMORY "C01110"
#define ELEKTRA_ERROR_OUT_OF_MEMORY "C01110"
#define ELEKTRA_WARNING_INSTALLATION "C01200"
#define ELEKTRA_ERROR_INSTALLATION "C01200"
#define ELEKTRA_WARNING_INTERNAL "C01310"
#define ELEKTRA_ERROR_INTERNAL "C01310"
#define ELEKTRA_WARNING_INTERFACE "C01320"
#define ELEKTRA_ERROR_INTERFACE "C01320"
#define ELEKTRA_WARNING_PLUGIN_MISBEHAVIOR "C01330"
#define ELEKTRA_ERROR_PLUGIN_MISBEHAVIOR "C01330"
#define ELEKTRA_WARNING_CONFLICTING_STATE "C02000"
#define ELEKTRA_ERROR_CONFLICTING_STATE "C02000"
#define ELEKTRA_WARNING_VALIDATION_SYNTACTIC "C03100"
#define ELEKTRA_ERROR_VALIDATION_SYNTACTIC "C03100"
#define ELEKTRA_WARNING_VALIDATION_SEMANTIC "C03200"
#define ELEKTRA_ERROR_VALIDATION_SEMANTIC "C03200"


static inline void elektraAddWarningfC01100(Key *warningKey, const char *reason,
	const char *file, const char *line, const char *module, ...)  __attribute__ ((format (printf, 2, 6)));
static inline void elektraAddWarningfC01100(Key *warningKey, const char *reason,
	const char *file, const char *line, const char *module, ...)
{
	if (!warningKey) return;

	char buffer[25] = "warnings/#00";buffer[12] = '\0';
	const Key *meta = keyGetMeta(warningKey, "warnings");
	if (meta)
	{
		buffer[10] = keyString(meta)[0];
		buffer[11] = keyString(meta)[1];
		buffer[11]++;
		if (buffer[11] > '9')
		{
			buffer[11] = '0';
			buffer[10]++;
			if (buffer[10] > '9') buffer[10] = '0';
		}
		keySetMeta(warningKey, "warnings", &buffer[10]);
	} else  keySetMeta(warningKey, "warnings", "00");

	keySetMeta(warningKey, buffer, "number description  module file line function reason");
	strcat(buffer, "/number" );
	keySetMeta(warningKey, buffer, "C01100");
	buffer[12] = '\0'; strcat(buffer, "/description");
	keySetMeta(warningKey, buffer, "Resource");
	buffer[12] = '\0'; strcat(buffer, "/module");
	if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
	keySetMeta(warningKey, buffer, module);
	buffer[12] = '\0'; strcat(buffer, "/file");
	keySetMeta(warningKey, buffer, file);
	buffer[12] = '\0'; strcat(buffer, "/line");
	keySetMeta(warningKey, buffer, line);
	buffer[12] = '\0'; strcat(buffer, "/mountpoint");
	keySetMeta(warningKey, buffer, keyName(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/configfile");
	keySetMeta(warningKey, buffer, keyString(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/reason");
	va_list arg;
	va_start(arg, module);
	char * r = elektraVFormat(reason, arg);
	keySetMeta(warningKey, buffer, r);
	elektraFree(r);
	va_end(arg);
}

static inline void elektraAddWarningC01100(Key *warningKey, const char *reason,
	const char *file, const char *line, const char *module)
{
	if (!warningKey) return;

	char buffer[25] = "warnings/#00";buffer[12] = '\0';
	const Key *meta = keyGetMeta(warningKey, "warnings");
	if (meta)
	{
		buffer[10] = keyString(meta)[0];
		buffer[11] = keyString(meta)[1];
		buffer[11]++;
		if (buffer[11] > '9')
		{
			buffer[11] = '0';
			buffer[10]++;
			if (buffer[10] > '9') buffer[10] = '0';
		}
		keySetMeta(warningKey, "warnings", &buffer[10]);
	} else  keySetMeta(warningKey, "warnings", "00");

	keySetMeta(warningKey, buffer, "number description  module file line function reason");
	strcat(buffer, "/number" );
	keySetMeta(warningKey, buffer, "C01100");
	buffer[12] = '\0'; strcat(buffer, "/description");
	keySetMeta(warningKey, buffer, "Resource");
	buffer[12] = '\0'; strcat(buffer, "/module");
	if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
	keySetMeta(warningKey, buffer, module);
	buffer[12] = '\0'; strcat(buffer, "/file");
	keySetMeta(warningKey, buffer, file);
	buffer[12] = '\0'; strcat(buffer, "/line");
	keySetMeta(warningKey, buffer, line);
	buffer[12] = '\0'; strcat(buffer, "/mountpoint");
	keySetMeta(warningKey, buffer, keyName(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/configfile");
	keySetMeta(warningKey, buffer, keyString(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/reason");
	keySetMeta(warningKey, buffer, reason);
}

static inline void elektraSetErrorfC01100(Key *errorKey, const char *reason,
	const char *file, const char *line, const char *module, ...)  __attribute__ ((format (printf, 2, 6)));
static inline void elektraSetErrorfC01100(Key *errorKey, const char *reason,
	const char *file, const char *line, const char *module, ...)
{
	if (!errorKey) return;
	char buffer[25] = "warnings/#00";
 	const Key *meta = keyGetMeta(errorKey, "error");
	if (meta)
	{
		const Key *warningMeta = keyGetMeta(errorKey, "warnings");
		if (warningMeta)
		{
			buffer[10] = keyString(warningMeta)[0];
			buffer[11] = keyString(warningMeta)[1];
			buffer[11]++;
			if (buffer[11] > '9')
			{
				buffer[11] = '0';
				buffer[10]++;
				if (buffer[10] > '9') buffer[10] = '0';
			}
			keySetMeta(errorKey, "warnings", &buffer[10]);
		} else	keySetMeta(errorKey, "warnings", "00");
		keySetMeta(errorKey, buffer, "number description  module file line function reason");
		strcat(buffer, "/number" );
		keySetMeta(errorKey, buffer, "C01100");
		buffer[12] = '\0'; strcat(buffer, "/description");
		keySetMeta(errorKey, buffer, "Resource");
		buffer[12] = '\0'; strcat(buffer, "/module");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, buffer, module);
		buffer[12] = '\0'; strcat(buffer, "/file");
		keySetMeta(errorKey, buffer, file);
		buffer[12] = '\0'; strcat(buffer, "/line");
		keySetMeta(errorKey, buffer, line);
		buffer[12] = '\0'; strcat(buffer, "/mountpoint");
		keySetMeta(errorKey, buffer, keyName(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/configfile");
		keySetMeta(errorKey, buffer, keyString(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/reason");
	}
 	else
 	{
		keySetMeta(errorKey, "error", "number description  module file line function reason");
		keySetMeta(errorKey, "error/number", "C01100");
		keySetMeta(errorKey, "error/description", "Resource");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, "error/module", module);
		keySetMeta(errorKey, "error/file", file);
		keySetMeta(errorKey, "error/line", line);
		keySetMeta(errorKey, "error/mountpoint", keyName(errorKey));
		keySetMeta(errorKey, "error/configfile", keyString(errorKey));
 	}
	va_list arg;
	va_start(arg, module);
	char * r = elektraVFormat(reason, arg);
 	if (meta)
			keySetMeta(errorKey, buffer, r);
 	else
			keySetMeta(errorKey, "error/reason", r);
	elektraFree(r);
	va_end(arg);
}

static inline void elektraSetErrorC01100(Key *errorKey, const char *reason,
	const char *file, const char *line, const char *module)
{
	if (!errorKey) return;
	char buffer[25] = "warnings/#00";
 	const Key *meta = keyGetMeta(errorKey, "error");
	if (meta)
	{
		const Key *warningMeta = keyGetMeta(errorKey, "warnings");
		if (warningMeta)
		{
			buffer[10] = keyString(warningMeta)[0];
			buffer[11] = keyString(warningMeta)[1];
			buffer[11]++;
			if (buffer[11] > '9')
			{
				buffer[11] = '0';
				buffer[10]++;
				if (buffer[10] > '9') buffer[10] = '0';
			}
			keySetMeta(errorKey, "warnings", &buffer[10]);
		} else	keySetMeta(errorKey, "warnings", "00");
		keySetMeta(errorKey, buffer, "number description  module file line function reason");
		strcat(buffer, "/number" );
		keySetMeta(errorKey, buffer, "C01100");
		buffer[12] = '\0'; strcat(buffer, "/description");
		keySetMeta(errorKey, buffer, "Resource");
		buffer[12] = '\0'; strcat(buffer, "/module");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, buffer, module);
		buffer[12] = '\0'; strcat(buffer, "/file");
		keySetMeta(errorKey, buffer, file);
		buffer[12] = '\0'; strcat(buffer, "/line");
		keySetMeta(errorKey, buffer, line);
		buffer[12] = '\0'; strcat(buffer, "/mountpoint");
		keySetMeta(errorKey, buffer, keyName(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/configfile");
		keySetMeta(errorKey, buffer, keyString(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/reason");
	}
 	else
 	{
		keySetMeta(errorKey, "error", "number description  module file line function reason");
		keySetMeta(errorKey, "error/number", "C01100");
		keySetMeta(errorKey, "error/description", "Resource");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, "error/module", module);
		keySetMeta(errorKey, "error/file", file);
		keySetMeta(errorKey, "error/line", line);
		keySetMeta(errorKey, "error/mountpoint", keyName(errorKey));
		keySetMeta(errorKey, "error/configfile", keyString(errorKey));
 	}
 	if (meta)
			keySetMeta(errorKey, buffer, reason);
 	else
			keySetMeta(errorKey, "error/reason", reason);
}

static inline void elektraAddWarningfC01110(Key *warningKey, const char *reason,
	const char *file, const char *line, const char *module, ...)  __attribute__ ((format (printf, 2, 6)));
static inline void elektraAddWarningfC01110(Key *warningKey, const char *reason,
	const char *file, const char *line, const char *module, ...)
{
	if (!warningKey) return;

	char buffer[25] = "warnings/#00";buffer[12] = '\0';
	const Key *meta = keyGetMeta(warningKey, "warnings");
	if (meta)
	{
		buffer[10] = keyString(meta)[0];
		buffer[11] = keyString(meta)[1];
		buffer[11]++;
		if (buffer[11] > '9')
		{
			buffer[11] = '0';
			buffer[10]++;
			if (buffer[10] > '9') buffer[10] = '0';
		}
		keySetMeta(warningKey, "warnings", &buffer[10]);
	} else  keySetMeta(warningKey, "warnings", "00");

	keySetMeta(warningKey, buffer, "number description  module file line function reason");
	strcat(buffer, "/number" );
	keySetMeta(warningKey, buffer, "C01110");
	buffer[12] = '\0'; strcat(buffer, "/description");
	keySetMeta(warningKey, buffer, "Out of Memory");
	buffer[12] = '\0'; strcat(buffer, "/module");
	if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
	keySetMeta(warningKey, buffer, module);
	buffer[12] = '\0'; strcat(buffer, "/file");
	keySetMeta(warningKey, buffer, file);
	buffer[12] = '\0'; strcat(buffer, "/line");
	keySetMeta(warningKey, buffer, line);
	buffer[12] = '\0'; strcat(buffer, "/mountpoint");
	keySetMeta(warningKey, buffer, keyName(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/configfile");
	keySetMeta(warningKey, buffer, keyString(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/reason");
	va_list arg;
	va_start(arg, module);
	char * r = elektraVFormat(reason, arg);
	keySetMeta(warningKey, buffer, r);
	elektraFree(r);
	va_end(arg);
}

static inline void elektraAddWarningC01110(Key *warningKey, const char *reason,
	const char *file, const char *line, const char *module)
{
	if (!warningKey) return;

	char buffer[25] = "warnings/#00";buffer[12] = '\0';
	const Key *meta = keyGetMeta(warningKey, "warnings");
	if (meta)
	{
		buffer[10] = keyString(meta)[0];
		buffer[11] = keyString(meta)[1];
		buffer[11]++;
		if (buffer[11] > '9')
		{
			buffer[11] = '0';
			buffer[10]++;
			if (buffer[10] > '9') buffer[10] = '0';
		}
		keySetMeta(warningKey, "warnings", &buffer[10]);
	} else  keySetMeta(warningKey, "warnings", "00");

	keySetMeta(warningKey, buffer, "number description  module file line function reason");
	strcat(buffer, "/number" );
	keySetMeta(warningKey, buffer, "C01110");
	buffer[12] = '\0'; strcat(buffer, "/description");
	keySetMeta(warningKey, buffer, "Out of Memory");
	buffer[12] = '\0'; strcat(buffer, "/module");
	if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
	keySetMeta(warningKey, buffer, module);
	buffer[12] = '\0'; strcat(buffer, "/file");
	keySetMeta(warningKey, buffer, file);
	buffer[12] = '\0'; strcat(buffer, "/line");
	keySetMeta(warningKey, buffer, line);
	buffer[12] = '\0'; strcat(buffer, "/mountpoint");
	keySetMeta(warningKey, buffer, keyName(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/configfile");
	keySetMeta(warningKey, buffer, keyString(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/reason");
	keySetMeta(warningKey, buffer, reason);
}

static inline void elektraSetErrorfC01110(Key *errorKey, const char *reason,
	const char *file, const char *line, const char *module, ...)  __attribute__ ((format (printf, 2, 6)));
static inline void elektraSetErrorfC01110(Key *errorKey, const char *reason,
	const char *file, const char *line, const char *module, ...)
{
	if (!errorKey) return;
	char buffer[25] = "warnings/#00";
 	const Key *meta = keyGetMeta(errorKey, "error");
	if (meta)
	{
		const Key *warningMeta = keyGetMeta(errorKey, "warnings");
		if (warningMeta)
		{
			buffer[10] = keyString(warningMeta)[0];
			buffer[11] = keyString(warningMeta)[1];
			buffer[11]++;
			if (buffer[11] > '9')
			{
				buffer[11] = '0';
				buffer[10]++;
				if (buffer[10] > '9') buffer[10] = '0';
			}
			keySetMeta(errorKey, "warnings", &buffer[10]);
		} else	keySetMeta(errorKey, "warnings", "00");
		keySetMeta(errorKey, buffer, "number description  module file line function reason");
		strcat(buffer, "/number" );
		keySetMeta(errorKey, buffer, "C01110");
		buffer[12] = '\0'; strcat(buffer, "/description");
		keySetMeta(errorKey, buffer, "Out of Memory");
		buffer[12] = '\0'; strcat(buffer, "/module");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, buffer, module);
		buffer[12] = '\0'; strcat(buffer, "/file");
		keySetMeta(errorKey, buffer, file);
		buffer[12] = '\0'; strcat(buffer, "/line");
		keySetMeta(errorKey, buffer, line);
		buffer[12] = '\0'; strcat(buffer, "/mountpoint");
		keySetMeta(errorKey, buffer, keyName(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/configfile");
		keySetMeta(errorKey, buffer, keyString(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/reason");
	}
 	else
 	{
		keySetMeta(errorKey, "error", "number description  module file line function reason");
		keySetMeta(errorKey, "error/number", "C01110");
		keySetMeta(errorKey, "error/description", "Out of Memory");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, "error/module", module);
		keySetMeta(errorKey, "error/file", file);
		keySetMeta(errorKey, "error/line", line);
		keySetMeta(errorKey, "error/mountpoint", keyName(errorKey));
		keySetMeta(errorKey, "error/configfile", keyString(errorKey));
 	}
	va_list arg;
	va_start(arg, module);
	char * r = elektraVFormat(reason, arg);
 	if (meta)
			keySetMeta(errorKey, buffer, r);
 	else
			keySetMeta(errorKey, "error/reason", r);
	elektraFree(r);
	va_end(arg);
}

static inline void elektraSetErrorC01110(Key *errorKey, const char *reason,
	const char *file, const char *line, const char *module)
{
	if (!errorKey) return;
	char buffer[25] = "warnings/#00";
 	const Key *meta = keyGetMeta(errorKey, "error");
	if (meta)
	{
		const Key *warningMeta = keyGetMeta(errorKey, "warnings");
		if (warningMeta)
		{
			buffer[10] = keyString(warningMeta)[0];
			buffer[11] = keyString(warningMeta)[1];
			buffer[11]++;
			if (buffer[11] > '9')
			{
				buffer[11] = '0';
				buffer[10]++;
				if (buffer[10] > '9') buffer[10] = '0';
			}
			keySetMeta(errorKey, "warnings", &buffer[10]);
		} else	keySetMeta(errorKey, "warnings", "00");
		keySetMeta(errorKey, buffer, "number description  module file line function reason");
		strcat(buffer, "/number" );
		keySetMeta(errorKey, buffer, "C01110");
		buffer[12] = '\0'; strcat(buffer, "/description");
		keySetMeta(errorKey, buffer, "Out of Memory");
		buffer[12] = '\0'; strcat(buffer, "/module");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, buffer, module);
		buffer[12] = '\0'; strcat(buffer, "/file");
		keySetMeta(errorKey, buffer, file);
		buffer[12] = '\0'; strcat(buffer, "/line");
		keySetMeta(errorKey, buffer, line);
		buffer[12] = '\0'; strcat(buffer, "/mountpoint");
		keySetMeta(errorKey, buffer, keyName(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/configfile");
		keySetMeta(errorKey, buffer, keyString(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/reason");
	}
 	else
 	{
		keySetMeta(errorKey, "error", "number description  module file line function reason");
		keySetMeta(errorKey, "error/number", "C01110");
		keySetMeta(errorKey, "error/description", "Out of Memory");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, "error/module", module);
		keySetMeta(errorKey, "error/file", file);
		keySetMeta(errorKey, "error/line", line);
		keySetMeta(errorKey, "error/mountpoint", keyName(errorKey));
		keySetMeta(errorKey, "error/configfile", keyString(errorKey));
 	}
 	if (meta)
			keySetMeta(errorKey, buffer, reason);
 	else
			keySetMeta(errorKey, "error/reason", reason);
}

static inline void elektraAddWarningfC01200(Key *warningKey, const char *reason,
	const char *file, const char *line, const char *module, ...)  __attribute__ ((format (printf, 2, 6)));
static inline void elektraAddWarningfC01200(Key *warningKey, const char *reason,
	const char *file, const char *line, const char *module, ...)
{
	if (!warningKey) return;

	char buffer[25] = "warnings/#00";buffer[12] = '\0';
	const Key *meta = keyGetMeta(warningKey, "warnings");
	if (meta)
	{
		buffer[10] = keyString(meta)[0];
		buffer[11] = keyString(meta)[1];
		buffer[11]++;
		if (buffer[11] > '9')
		{
			buffer[11] = '0';
			buffer[10]++;
			if (buffer[10] > '9') buffer[10] = '0';
		}
		keySetMeta(warningKey, "warnings", &buffer[10]);
	} else  keySetMeta(warningKey, "warnings", "00");

	keySetMeta(warningKey, buffer, "number description  module file line function reason");
	strcat(buffer, "/number" );
	keySetMeta(warningKey, buffer, "C01200");
	buffer[12] = '\0'; strcat(buffer, "/description");
	keySetMeta(warningKey, buffer, "Installation");
	buffer[12] = '\0'; strcat(buffer, "/module");
	if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
	keySetMeta(warningKey, buffer, module);
	buffer[12] = '\0'; strcat(buffer, "/file");
	keySetMeta(warningKey, buffer, file);
	buffer[12] = '\0'; strcat(buffer, "/line");
	keySetMeta(warningKey, buffer, line);
	buffer[12] = '\0'; strcat(buffer, "/mountpoint");
	keySetMeta(warningKey, buffer, keyName(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/configfile");
	keySetMeta(warningKey, buffer, keyString(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/reason");
	va_list arg;
	va_start(arg, module);
	char * r = elektraVFormat(reason, arg);
	keySetMeta(warningKey, buffer, r);
	elektraFree(r);
	va_end(arg);
}

static inline void elektraAddWarningC01200(Key *warningKey, const char *reason,
	const char *file, const char *line, const char *module)
{
	if (!warningKey) return;

	char buffer[25] = "warnings/#00";buffer[12] = '\0';
	const Key *meta = keyGetMeta(warningKey, "warnings");
	if (meta)
	{
		buffer[10] = keyString(meta)[0];
		buffer[11] = keyString(meta)[1];
		buffer[11]++;
		if (buffer[11] > '9')
		{
			buffer[11] = '0';
			buffer[10]++;
			if (buffer[10] > '9') buffer[10] = '0';
		}
		keySetMeta(warningKey, "warnings", &buffer[10]);
	} else  keySetMeta(warningKey, "warnings", "00");

	keySetMeta(warningKey, buffer, "number description  module file line function reason");
	strcat(buffer, "/number" );
	keySetMeta(warningKey, buffer, "C01200");
	buffer[12] = '\0'; strcat(buffer, "/description");
	keySetMeta(warningKey, buffer, "Installation");
	buffer[12] = '\0'; strcat(buffer, "/module");
	if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
	keySetMeta(warningKey, buffer, module);
	buffer[12] = '\0'; strcat(buffer, "/file");
	keySetMeta(warningKey, buffer, file);
	buffer[12] = '\0'; strcat(buffer, "/line");
	keySetMeta(warningKey, buffer, line);
	buffer[12] = '\0'; strcat(buffer, "/mountpoint");
	keySetMeta(warningKey, buffer, keyName(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/configfile");
	keySetMeta(warningKey, buffer, keyString(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/reason");
	keySetMeta(warningKey, buffer, reason);
}

static inline void elektraSetErrorfC01200(Key *errorKey, const char *reason,
	const char *file, const char *line, const char *module, ...)  __attribute__ ((format (printf, 2, 6)));
static inline void elektraSetErrorfC01200(Key *errorKey, const char *reason,
	const char *file, const char *line, const char *module, ...)
{
	if (!errorKey) return;
	char buffer[25] = "warnings/#00";
 	const Key *meta = keyGetMeta(errorKey, "error");
	if (meta)
	{
		const Key *warningMeta = keyGetMeta(errorKey, "warnings");
		if (warningMeta)
		{
			buffer[10] = keyString(warningMeta)[0];
			buffer[11] = keyString(warningMeta)[1];
			buffer[11]++;
			if (buffer[11] > '9')
			{
				buffer[11] = '0';
				buffer[10]++;
				if (buffer[10] > '9') buffer[10] = '0';
			}
			keySetMeta(errorKey, "warnings", &buffer[10]);
		} else	keySetMeta(errorKey, "warnings", "00");
		keySetMeta(errorKey, buffer, "number description  module file line function reason");
		strcat(buffer, "/number" );
		keySetMeta(errorKey, buffer, "C01200");
		buffer[12] = '\0'; strcat(buffer, "/description");
		keySetMeta(errorKey, buffer, "Installation");
		buffer[12] = '\0'; strcat(buffer, "/module");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, buffer, module);
		buffer[12] = '\0'; strcat(buffer, "/file");
		keySetMeta(errorKey, buffer, file);
		buffer[12] = '\0'; strcat(buffer, "/line");
		keySetMeta(errorKey, buffer, line);
		buffer[12] = '\0'; strcat(buffer, "/mountpoint");
		keySetMeta(errorKey, buffer, keyName(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/configfile");
		keySetMeta(errorKey, buffer, keyString(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/reason");
	}
 	else
 	{
		keySetMeta(errorKey, "error", "number description  module file line function reason");
		keySetMeta(errorKey, "error/number", "C01200");
		keySetMeta(errorKey, "error/description", "Installation");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, "error/module", module);
		keySetMeta(errorKey, "error/file", file);
		keySetMeta(errorKey, "error/line", line);
		keySetMeta(errorKey, "error/mountpoint", keyName(errorKey));
		keySetMeta(errorKey, "error/configfile", keyString(errorKey));
 	}
	va_list arg;
	va_start(arg, module);
	char * r = elektraVFormat(reason, arg);
 	if (meta)
			keySetMeta(errorKey, buffer, r);
 	else
			keySetMeta(errorKey, "error/reason", r);
	elektraFree(r);
	va_end(arg);
}

static inline void elektraSetErrorC01200(Key *errorKey, const char *reason,
	const char *file, const char *line, const char *module)
{
	if (!errorKey) return;
	char buffer[25] = "warnings/#00";
 	const Key *meta = keyGetMeta(errorKey, "error");
	if (meta)
	{
		const Key *warningMeta = keyGetMeta(errorKey, "warnings");
		if (warningMeta)
		{
			buffer[10] = keyString(warningMeta)[0];
			buffer[11] = keyString(warningMeta)[1];
			buffer[11]++;
			if (buffer[11] > '9')
			{
				buffer[11] = '0';
				buffer[10]++;
				if (buffer[10] > '9') buffer[10] = '0';
			}
			keySetMeta(errorKey, "warnings", &buffer[10]);
		} else	keySetMeta(errorKey, "warnings", "00");
		keySetMeta(errorKey, buffer, "number description  module file line function reason");
		strcat(buffer, "/number" );
		keySetMeta(errorKey, buffer, "C01200");
		buffer[12] = '\0'; strcat(buffer, "/description");
		keySetMeta(errorKey, buffer, "Installation");
		buffer[12] = '\0'; strcat(buffer, "/module");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, buffer, module);
		buffer[12] = '\0'; strcat(buffer, "/file");
		keySetMeta(errorKey, buffer, file);
		buffer[12] = '\0'; strcat(buffer, "/line");
		keySetMeta(errorKey, buffer, line);
		buffer[12] = '\0'; strcat(buffer, "/mountpoint");
		keySetMeta(errorKey, buffer, keyName(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/configfile");
		keySetMeta(errorKey, buffer, keyString(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/reason");
	}
 	else
 	{
		keySetMeta(errorKey, "error", "number description  module file line function reason");
		keySetMeta(errorKey, "error/number", "C01200");
		keySetMeta(errorKey, "error/description", "Installation");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, "error/module", module);
		keySetMeta(errorKey, "error/file", file);
		keySetMeta(errorKey, "error/line", line);
		keySetMeta(errorKey, "error/mountpoint", keyName(errorKey));
		keySetMeta(errorKey, "error/configfile", keyString(errorKey));
 	}
 	if (meta)
			keySetMeta(errorKey, buffer, reason);
 	else
			keySetMeta(errorKey, "error/reason", reason);
}

static inline void elektraAddWarningfC01310(Key *warningKey, const char *reason,
	const char *file, const char *line, const char *module, ...)  __attribute__ ((format (printf, 2, 6)));
static inline void elektraAddWarningfC01310(Key *warningKey, const char *reason,
	const char *file, const char *line, const char *module, ...)
{
	if (!warningKey) return;

	char buffer[25] = "warnings/#00";buffer[12] = '\0';
	const Key *meta = keyGetMeta(warningKey, "warnings");
	if (meta)
	{
		buffer[10] = keyString(meta)[0];
		buffer[11] = keyString(meta)[1];
		buffer[11]++;
		if (buffer[11] > '9')
		{
			buffer[11] = '0';
			buffer[10]++;
			if (buffer[10] > '9') buffer[10] = '0';
		}
		keySetMeta(warningKey, "warnings", &buffer[10]);
	} else  keySetMeta(warningKey, "warnings", "00");

	keySetMeta(warningKey, buffer, "number description  module file line function reason");
	strcat(buffer, "/number" );
	keySetMeta(warningKey, buffer, "C01310");
	buffer[12] = '\0'; strcat(buffer, "/description");
	keySetMeta(warningKey, buffer, "Internal");
	buffer[12] = '\0'; strcat(buffer, "/module");
	if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
	keySetMeta(warningKey, buffer, module);
	buffer[12] = '\0'; strcat(buffer, "/file");
	keySetMeta(warningKey, buffer, file);
	buffer[12] = '\0'; strcat(buffer, "/line");
	keySetMeta(warningKey, buffer, line);
	buffer[12] = '\0'; strcat(buffer, "/mountpoint");
	keySetMeta(warningKey, buffer, keyName(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/configfile");
	keySetMeta(warningKey, buffer, keyString(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/reason");
	va_list arg;
	va_start(arg, module);
	char * r = elektraVFormat(reason, arg);
	keySetMeta(warningKey, buffer, r);
	elektraFree(r);
	va_end(arg);
}

static inline void elektraAddWarningC01310(Key *warningKey, const char *reason,
	const char *file, const char *line, const char *module)
{
	if (!warningKey) return;

	char buffer[25] = "warnings/#00";buffer[12] = '\0';
	const Key *meta = keyGetMeta(warningKey, "warnings");
	if (meta)
	{
		buffer[10] = keyString(meta)[0];
		buffer[11] = keyString(meta)[1];
		buffer[11]++;
		if (buffer[11] > '9')
		{
			buffer[11] = '0';
			buffer[10]++;
			if (buffer[10] > '9') buffer[10] = '0';
		}
		keySetMeta(warningKey, "warnings", &buffer[10]);
	} else  keySetMeta(warningKey, "warnings", "00");

	keySetMeta(warningKey, buffer, "number description  module file line function reason");
	strcat(buffer, "/number" );
	keySetMeta(warningKey, buffer, "C01310");
	buffer[12] = '\0'; strcat(buffer, "/description");
	keySetMeta(warningKey, buffer, "Internal");
	buffer[12] = '\0'; strcat(buffer, "/module");
	if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
	keySetMeta(warningKey, buffer, module);
	buffer[12] = '\0'; strcat(buffer, "/file");
	keySetMeta(warningKey, buffer, file);
	buffer[12] = '\0'; strcat(buffer, "/line");
	keySetMeta(warningKey, buffer, line);
	buffer[12] = '\0'; strcat(buffer, "/mountpoint");
	keySetMeta(warningKey, buffer, keyName(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/configfile");
	keySetMeta(warningKey, buffer, keyString(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/reason");
	keySetMeta(warningKey, buffer, reason);
}

static inline void elektraSetErrorfC01310(Key *errorKey, const char *reason,
	const char *file, const char *line, const char *module, ...)  __attribute__ ((format (printf, 2, 6)));
static inline void elektraSetErrorfC01310(Key *errorKey, const char *reason,
	const char *file, const char *line, const char *module, ...)
{
	if (!errorKey) return;
	char buffer[25] = "warnings/#00";
 	const Key *meta = keyGetMeta(errorKey, "error");
	if (meta)
	{
		const Key *warningMeta = keyGetMeta(errorKey, "warnings");
		if (warningMeta)
		{
			buffer[10] = keyString(warningMeta)[0];
			buffer[11] = keyString(warningMeta)[1];
			buffer[11]++;
			if (buffer[11] > '9')
			{
				buffer[11] = '0';
				buffer[10]++;
				if (buffer[10] > '9') buffer[10] = '0';
			}
			keySetMeta(errorKey, "warnings", &buffer[10]);
		} else	keySetMeta(errorKey, "warnings", "00");
		keySetMeta(errorKey, buffer, "number description  module file line function reason");
		strcat(buffer, "/number" );
		keySetMeta(errorKey, buffer, "C01310");
		buffer[12] = '\0'; strcat(buffer, "/description");
		keySetMeta(errorKey, buffer, "Internal");
		buffer[12] = '\0'; strcat(buffer, "/module");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, buffer, module);
		buffer[12] = '\0'; strcat(buffer, "/file");
		keySetMeta(errorKey, buffer, file);
		buffer[12] = '\0'; strcat(buffer, "/line");
		keySetMeta(errorKey, buffer, line);
		buffer[12] = '\0'; strcat(buffer, "/mountpoint");
		keySetMeta(errorKey, buffer, keyName(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/configfile");
		keySetMeta(errorKey, buffer, keyString(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/reason");
	}
 	else
 	{
		keySetMeta(errorKey, "error", "number description  module file line function reason");
		keySetMeta(errorKey, "error/number", "C01310");
		keySetMeta(errorKey, "error/description", "Internal");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, "error/module", module);
		keySetMeta(errorKey, "error/file", file);
		keySetMeta(errorKey, "error/line", line);
		keySetMeta(errorKey, "error/mountpoint", keyName(errorKey));
		keySetMeta(errorKey, "error/configfile", keyString(errorKey));
 	}
	va_list arg;
	va_start(arg, module);
	char * r = elektraVFormat(reason, arg);
 	if (meta)
			keySetMeta(errorKey, buffer, r);
 	else
			keySetMeta(errorKey, "error/reason", r);
	elektraFree(r);
	va_end(arg);
}

static inline void elektraSetErrorC01310(Key *errorKey, const char *reason,
	const char *file, const char *line, const char *module)
{
	if (!errorKey) return;
	char buffer[25] = "warnings/#00";
 	const Key *meta = keyGetMeta(errorKey, "error");
	if (meta)
	{
		const Key *warningMeta = keyGetMeta(errorKey, "warnings");
		if (warningMeta)
		{
			buffer[10] = keyString(warningMeta)[0];
			buffer[11] = keyString(warningMeta)[1];
			buffer[11]++;
			if (buffer[11] > '9')
			{
				buffer[11] = '0';
				buffer[10]++;
				if (buffer[10] > '9') buffer[10] = '0';
			}
			keySetMeta(errorKey, "warnings", &buffer[10]);
		} else	keySetMeta(errorKey, "warnings", "00");
		keySetMeta(errorKey, buffer, "number description  module file line function reason");
		strcat(buffer, "/number" );
		keySetMeta(errorKey, buffer, "C01310");
		buffer[12] = '\0'; strcat(buffer, "/description");
		keySetMeta(errorKey, buffer, "Internal");
		buffer[12] = '\0'; strcat(buffer, "/module");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, buffer, module);
		buffer[12] = '\0'; strcat(buffer, "/file");
		keySetMeta(errorKey, buffer, file);
		buffer[12] = '\0'; strcat(buffer, "/line");
		keySetMeta(errorKey, buffer, line);
		buffer[12] = '\0'; strcat(buffer, "/mountpoint");
		keySetMeta(errorKey, buffer, keyName(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/configfile");
		keySetMeta(errorKey, buffer, keyString(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/reason");
	}
 	else
 	{
		keySetMeta(errorKey, "error", "number description  module file line function reason");
		keySetMeta(errorKey, "error/number", "C01310");
		keySetMeta(errorKey, "error/description", "Internal");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, "error/module", module);
		keySetMeta(errorKey, "error/file", file);
		keySetMeta(errorKey, "error/line", line);
		keySetMeta(errorKey, "error/mountpoint", keyName(errorKey));
		keySetMeta(errorKey, "error/configfile", keyString(errorKey));
 	}
 	if (meta)
			keySetMeta(errorKey, buffer, reason);
 	else
			keySetMeta(errorKey, "error/reason", reason);
}

static inline void elektraAddWarningfC01320(Key *warningKey, const char *reason,
	const char *file, const char *line, const char *module, ...)  __attribute__ ((format (printf, 2, 6)));
static inline void elektraAddWarningfC01320(Key *warningKey, const char *reason,
	const char *file, const char *line, const char *module, ...)
{
	if (!warningKey) return;

	char buffer[25] = "warnings/#00";buffer[12] = '\0';
	const Key *meta = keyGetMeta(warningKey, "warnings");
	if (meta)
	{
		buffer[10] = keyString(meta)[0];
		buffer[11] = keyString(meta)[1];
		buffer[11]++;
		if (buffer[11] > '9')
		{
			buffer[11] = '0';
			buffer[10]++;
			if (buffer[10] > '9') buffer[10] = '0';
		}
		keySetMeta(warningKey, "warnings", &buffer[10]);
	} else  keySetMeta(warningKey, "warnings", "00");

	keySetMeta(warningKey, buffer, "number description  module file line function reason");
	strcat(buffer, "/number" );
	keySetMeta(warningKey, buffer, "C01320");
	buffer[12] = '\0'; strcat(buffer, "/description");
	keySetMeta(warningKey, buffer, "Interface");
	buffer[12] = '\0'; strcat(buffer, "/module");
	if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
	keySetMeta(warningKey, buffer, module);
	buffer[12] = '\0'; strcat(buffer, "/file");
	keySetMeta(warningKey, buffer, file);
	buffer[12] = '\0'; strcat(buffer, "/line");
	keySetMeta(warningKey, buffer, line);
	buffer[12] = '\0'; strcat(buffer, "/mountpoint");
	keySetMeta(warningKey, buffer, keyName(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/configfile");
	keySetMeta(warningKey, buffer, keyString(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/reason");
	va_list arg;
	va_start(arg, module);
	char * r = elektraVFormat(reason, arg);
	keySetMeta(warningKey, buffer, r);
	elektraFree(r);
	va_end(arg);
}

static inline void elektraAddWarningC01320(Key *warningKey, const char *reason,
	const char *file, const char *line, const char *module)
{
	if (!warningKey) return;

	char buffer[25] = "warnings/#00";buffer[12] = '\0';
	const Key *meta = keyGetMeta(warningKey, "warnings");
	if (meta)
	{
		buffer[10] = keyString(meta)[0];
		buffer[11] = keyString(meta)[1];
		buffer[11]++;
		if (buffer[11] > '9')
		{
			buffer[11] = '0';
			buffer[10]++;
			if (buffer[10] > '9') buffer[10] = '0';
		}
		keySetMeta(warningKey, "warnings", &buffer[10]);
	} else  keySetMeta(warningKey, "warnings", "00");

	keySetMeta(warningKey, buffer, "number description  module file line function reason");
	strcat(buffer, "/number" );
	keySetMeta(warningKey, buffer, "C01320");
	buffer[12] = '\0'; strcat(buffer, "/description");
	keySetMeta(warningKey, buffer, "Interface");
	buffer[12] = '\0'; strcat(buffer, "/module");
	if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
	keySetMeta(warningKey, buffer, module);
	buffer[12] = '\0'; strcat(buffer, "/file");
	keySetMeta(warningKey, buffer, file);
	buffer[12] = '\0'; strcat(buffer, "/line");
	keySetMeta(warningKey, buffer, line);
	buffer[12] = '\0'; strcat(buffer, "/mountpoint");
	keySetMeta(warningKey, buffer, keyName(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/configfile");
	keySetMeta(warningKey, buffer, keyString(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/reason");
	keySetMeta(warningKey, buffer, reason);
}

static inline void elektraSetErrorfC01320(Key *errorKey, const char *reason,
	const char *file, const char *line, const char *module, ...)  __attribute__ ((format (printf, 2, 6)));
static inline void elektraSetErrorfC01320(Key *errorKey, const char *reason,
	const char *file, const char *line, const char *module, ...)
{
	if (!errorKey) return;
	char buffer[25] = "warnings/#00";
 	const Key *meta = keyGetMeta(errorKey, "error");
	if (meta)
	{
		const Key *warningMeta = keyGetMeta(errorKey, "warnings");
		if (warningMeta)
		{
			buffer[10] = keyString(warningMeta)[0];
			buffer[11] = keyString(warningMeta)[1];
			buffer[11]++;
			if (buffer[11] > '9')
			{
				buffer[11] = '0';
				buffer[10]++;
				if (buffer[10] > '9') buffer[10] = '0';
			}
			keySetMeta(errorKey, "warnings", &buffer[10]);
		} else	keySetMeta(errorKey, "warnings", "00");
		keySetMeta(errorKey, buffer, "number description  module file line function reason");
		strcat(buffer, "/number" );
		keySetMeta(errorKey, buffer, "C01320");
		buffer[12] = '\0'; strcat(buffer, "/description");
		keySetMeta(errorKey, buffer, "Interface");
		buffer[12] = '\0'; strcat(buffer, "/module");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, buffer, module);
		buffer[12] = '\0'; strcat(buffer, "/file");
		keySetMeta(errorKey, buffer, file);
		buffer[12] = '\0'; strcat(buffer, "/line");
		keySetMeta(errorKey, buffer, line);
		buffer[12] = '\0'; strcat(buffer, "/mountpoint");
		keySetMeta(errorKey, buffer, keyName(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/configfile");
		keySetMeta(errorKey, buffer, keyString(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/reason");
	}
 	else
 	{
		keySetMeta(errorKey, "error", "number description  module file line function reason");
		keySetMeta(errorKey, "error/number", "C01320");
		keySetMeta(errorKey, "error/description", "Interface");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, "error/module", module);
		keySetMeta(errorKey, "error/file", file);
		keySetMeta(errorKey, "error/line", line);
		keySetMeta(errorKey, "error/mountpoint", keyName(errorKey));
		keySetMeta(errorKey, "error/configfile", keyString(errorKey));
 	}
	va_list arg;
	va_start(arg, module);
	char * r = elektraVFormat(reason, arg);
 	if (meta)
			keySetMeta(errorKey, buffer, r);
 	else
			keySetMeta(errorKey, "error/reason", r);
	elektraFree(r);
	va_end(arg);
}

static inline void elektraSetErrorC01320(Key *errorKey, const char *reason,
	const char *file, const char *line, const char *module)
{
	if (!errorKey) return;
	char buffer[25] = "warnings/#00";
 	const Key *meta = keyGetMeta(errorKey, "error");
	if (meta)
	{
		const Key *warningMeta = keyGetMeta(errorKey, "warnings");
		if (warningMeta)
		{
			buffer[10] = keyString(warningMeta)[0];
			buffer[11] = keyString(warningMeta)[1];
			buffer[11]++;
			if (buffer[11] > '9')
			{
				buffer[11] = '0';
				buffer[10]++;
				if (buffer[10] > '9') buffer[10] = '0';
			}
			keySetMeta(errorKey, "warnings", &buffer[10]);
		} else	keySetMeta(errorKey, "warnings", "00");
		keySetMeta(errorKey, buffer, "number description  module file line function reason");
		strcat(buffer, "/number" );
		keySetMeta(errorKey, buffer, "C01320");
		buffer[12] = '\0'; strcat(buffer, "/description");
		keySetMeta(errorKey, buffer, "Interface");
		buffer[12] = '\0'; strcat(buffer, "/module");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, buffer, module);
		buffer[12] = '\0'; strcat(buffer, "/file");
		keySetMeta(errorKey, buffer, file);
		buffer[12] = '\0'; strcat(buffer, "/line");
		keySetMeta(errorKey, buffer, line);
		buffer[12] = '\0'; strcat(buffer, "/mountpoint");
		keySetMeta(errorKey, buffer, keyName(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/configfile");
		keySetMeta(errorKey, buffer, keyString(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/reason");
	}
 	else
 	{
		keySetMeta(errorKey, "error", "number description  module file line function reason");
		keySetMeta(errorKey, "error/number", "C01320");
		keySetMeta(errorKey, "error/description", "Interface");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, "error/module", module);
		keySetMeta(errorKey, "error/file", file);
		keySetMeta(errorKey, "error/line", line);
		keySetMeta(errorKey, "error/mountpoint", keyName(errorKey));
		keySetMeta(errorKey, "error/configfile", keyString(errorKey));
 	}
 	if (meta)
			keySetMeta(errorKey, buffer, reason);
 	else
			keySetMeta(errorKey, "error/reason", reason);
}

static inline void elektraAddWarningfC01330(Key *warningKey, const char *reason,
	const char *file, const char *line, const char *module, ...)  __attribute__ ((format (printf, 2, 6)));
static inline void elektraAddWarningfC01330(Key *warningKey, const char *reason,
	const char *file, const char *line, const char *module, ...)
{
	if (!warningKey) return;

	char buffer[25] = "warnings/#00";buffer[12] = '\0';
	const Key *meta = keyGetMeta(warningKey, "warnings");
	if (meta)
	{
		buffer[10] = keyString(meta)[0];
		buffer[11] = keyString(meta)[1];
		buffer[11]++;
		if (buffer[11] > '9')
		{
			buffer[11] = '0';
			buffer[10]++;
			if (buffer[10] > '9') buffer[10] = '0';
		}
		keySetMeta(warningKey, "warnings", &buffer[10]);
	} else  keySetMeta(warningKey, "warnings", "00");

	keySetMeta(warningKey, buffer, "number description  module file line function reason");
	strcat(buffer, "/number" );
	keySetMeta(warningKey, buffer, "C01330");
	buffer[12] = '\0'; strcat(buffer, "/description");
	keySetMeta(warningKey, buffer, "Plugin Misbehavior");
	buffer[12] = '\0'; strcat(buffer, "/module");
	if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
	keySetMeta(warningKey, buffer, module);
	buffer[12] = '\0'; strcat(buffer, "/file");
	keySetMeta(warningKey, buffer, file);
	buffer[12] = '\0'; strcat(buffer, "/line");
	keySetMeta(warningKey, buffer, line);
	buffer[12] = '\0'; strcat(buffer, "/mountpoint");
	keySetMeta(warningKey, buffer, keyName(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/configfile");
	keySetMeta(warningKey, buffer, keyString(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/reason");
	va_list arg;
	va_start(arg, module);
	char * r = elektraVFormat(reason, arg);
	keySetMeta(warningKey, buffer, r);
	elektraFree(r);
	va_end(arg);
}

static inline void elektraAddWarningC01330(Key *warningKey, const char *reason,
	const char *file, const char *line, const char *module)
{
	if (!warningKey) return;

	char buffer[25] = "warnings/#00";buffer[12] = '\0';
	const Key *meta = keyGetMeta(warningKey, "warnings");
	if (meta)
	{
		buffer[10] = keyString(meta)[0];
		buffer[11] = keyString(meta)[1];
		buffer[11]++;
		if (buffer[11] > '9')
		{
			buffer[11] = '0';
			buffer[10]++;
			if (buffer[10] > '9') buffer[10] = '0';
		}
		keySetMeta(warningKey, "warnings", &buffer[10]);
	} else  keySetMeta(warningKey, "warnings", "00");

	keySetMeta(warningKey, buffer, "number description  module file line function reason");
	strcat(buffer, "/number" );
	keySetMeta(warningKey, buffer, "C01330");
	buffer[12] = '\0'; strcat(buffer, "/description");
	keySetMeta(warningKey, buffer, "Plugin Misbehavior");
	buffer[12] = '\0'; strcat(buffer, "/module");
	if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
	keySetMeta(warningKey, buffer, module);
	buffer[12] = '\0'; strcat(buffer, "/file");
	keySetMeta(warningKey, buffer, file);
	buffer[12] = '\0'; strcat(buffer, "/line");
	keySetMeta(warningKey, buffer, line);
	buffer[12] = '\0'; strcat(buffer, "/mountpoint");
	keySetMeta(warningKey, buffer, keyName(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/configfile");
	keySetMeta(warningKey, buffer, keyString(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/reason");
	keySetMeta(warningKey, buffer, reason);
}

static inline void elektraSetErrorfC01330(Key *errorKey, const char *reason,
	const char *file, const char *line, const char *module, ...)  __attribute__ ((format (printf, 2, 6)));
static inline void elektraSetErrorfC01330(Key *errorKey, const char *reason,
	const char *file, const char *line, const char *module, ...)
{
	if (!errorKey) return;
	char buffer[25] = "warnings/#00";
 	const Key *meta = keyGetMeta(errorKey, "error");
	if (meta)
	{
		const Key *warningMeta = keyGetMeta(errorKey, "warnings");
		if (warningMeta)
		{
			buffer[10] = keyString(warningMeta)[0];
			buffer[11] = keyString(warningMeta)[1];
			buffer[11]++;
			if (buffer[11] > '9')
			{
				buffer[11] = '0';
				buffer[10]++;
				if (buffer[10] > '9') buffer[10] = '0';
			}
			keySetMeta(errorKey, "warnings", &buffer[10]);
		} else	keySetMeta(errorKey, "warnings", "00");
		keySetMeta(errorKey, buffer, "number description  module file line function reason");
		strcat(buffer, "/number" );
		keySetMeta(errorKey, buffer, "C01330");
		buffer[12] = '\0'; strcat(buffer, "/description");
		keySetMeta(errorKey, buffer, "Plugin Misbehavior");
		buffer[12] = '\0'; strcat(buffer, "/module");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, buffer, module);
		buffer[12] = '\0'; strcat(buffer, "/file");
		keySetMeta(errorKey, buffer, file);
		buffer[12] = '\0'; strcat(buffer, "/line");
		keySetMeta(errorKey, buffer, line);
		buffer[12] = '\0'; strcat(buffer, "/mountpoint");
		keySetMeta(errorKey, buffer, keyName(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/configfile");
		keySetMeta(errorKey, buffer, keyString(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/reason");
	}
 	else
 	{
		keySetMeta(errorKey, "error", "number description  module file line function reason");
		keySetMeta(errorKey, "error/number", "C01330");
		keySetMeta(errorKey, "error/description", "Plugin Misbehavior");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, "error/module", module);
		keySetMeta(errorKey, "error/file", file);
		keySetMeta(errorKey, "error/line", line);
		keySetMeta(errorKey, "error/mountpoint", keyName(errorKey));
		keySetMeta(errorKey, "error/configfile", keyString(errorKey));
 	}
	va_list arg;
	va_start(arg, module);
	char * r = elektraVFormat(reason, arg);
 	if (meta)
			keySetMeta(errorKey, buffer, r);
 	else
			keySetMeta(errorKey, "error/reason", r);
	elektraFree(r);
	va_end(arg);
}

static inline void elektraSetErrorC01330(Key *errorKey, const char *reason,
	const char *file, const char *line, const char *module)
{
	if (!errorKey) return;
	char buffer[25] = "warnings/#00";
 	const Key *meta = keyGetMeta(errorKey, "error");
	if (meta)
	{
		const Key *warningMeta = keyGetMeta(errorKey, "warnings");
		if (warningMeta)
		{
			buffer[10] = keyString(warningMeta)[0];
			buffer[11] = keyString(warningMeta)[1];
			buffer[11]++;
			if (buffer[11] > '9')
			{
				buffer[11] = '0';
				buffer[10]++;
				if (buffer[10] > '9') buffer[10] = '0';
			}
			keySetMeta(errorKey, "warnings", &buffer[10]);
		} else	keySetMeta(errorKey, "warnings", "00");
		keySetMeta(errorKey, buffer, "number description  module file line function reason");
		strcat(buffer, "/number" );
		keySetMeta(errorKey, buffer, "C01330");
		buffer[12] = '\0'; strcat(buffer, "/description");
		keySetMeta(errorKey, buffer, "Plugin Misbehavior");
		buffer[12] = '\0'; strcat(buffer, "/module");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, buffer, module);
		buffer[12] = '\0'; strcat(buffer, "/file");
		keySetMeta(errorKey, buffer, file);
		buffer[12] = '\0'; strcat(buffer, "/line");
		keySetMeta(errorKey, buffer, line);
		buffer[12] = '\0'; strcat(buffer, "/mountpoint");
		keySetMeta(errorKey, buffer, keyName(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/configfile");
		keySetMeta(errorKey, buffer, keyString(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/reason");
	}
 	else
 	{
		keySetMeta(errorKey, "error", "number description  module file line function reason");
		keySetMeta(errorKey, "error/number", "C01330");
		keySetMeta(errorKey, "error/description", "Plugin Misbehavior");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, "error/module", module);
		keySetMeta(errorKey, "error/file", file);
		keySetMeta(errorKey, "error/line", line);
		keySetMeta(errorKey, "error/mountpoint", keyName(errorKey));
		keySetMeta(errorKey, "error/configfile", keyString(errorKey));
 	}
 	if (meta)
			keySetMeta(errorKey, buffer, reason);
 	else
			keySetMeta(errorKey, "error/reason", reason);
}

static inline void elektraAddWarningfC02000(Key *warningKey, const char *reason,
	const char *file, const char *line, const char *module, ...)  __attribute__ ((format (printf, 2, 6)));
static inline void elektraAddWarningfC02000(Key *warningKey, const char *reason,
	const char *file, const char *line, const char *module, ...)
{
	if (!warningKey) return;

	char buffer[25] = "warnings/#00";buffer[12] = '\0';
	const Key *meta = keyGetMeta(warningKey, "warnings");
	if (meta)
	{
		buffer[10] = keyString(meta)[0];
		buffer[11] = keyString(meta)[1];
		buffer[11]++;
		if (buffer[11] > '9')
		{
			buffer[11] = '0';
			buffer[10]++;
			if (buffer[10] > '9') buffer[10] = '0';
		}
		keySetMeta(warningKey, "warnings", &buffer[10]);
	} else  keySetMeta(warningKey, "warnings", "00");

	keySetMeta(warningKey, buffer, "number description  module file line function reason");
	strcat(buffer, "/number" );
	keySetMeta(warningKey, buffer, "C02000");
	buffer[12] = '\0'; strcat(buffer, "/description");
	keySetMeta(warningKey, buffer, "Conflict");
	buffer[12] = '\0'; strcat(buffer, "/module");
	if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
	keySetMeta(warningKey, buffer, module);
	buffer[12] = '\0'; strcat(buffer, "/file");
	keySetMeta(warningKey, buffer, file);
	buffer[12] = '\0'; strcat(buffer, "/line");
	keySetMeta(warningKey, buffer, line);
	buffer[12] = '\0'; strcat(buffer, "/mountpoint");
	keySetMeta(warningKey, buffer, keyName(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/configfile");
	keySetMeta(warningKey, buffer, keyString(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/reason");
	va_list arg;
	va_start(arg, module);
	char * r = elektraVFormat(reason, arg);
	keySetMeta(warningKey, buffer, r);
	elektraFree(r);
	va_end(arg);
}

static inline void elektraAddWarningC02000(Key *warningKey, const char *reason,
	const char *file, const char *line, const char *module)
{
	if (!warningKey) return;

	char buffer[25] = "warnings/#00";buffer[12] = '\0';
	const Key *meta = keyGetMeta(warningKey, "warnings");
	if (meta)
	{
		buffer[10] = keyString(meta)[0];
		buffer[11] = keyString(meta)[1];
		buffer[11]++;
		if (buffer[11] > '9')
		{
			buffer[11] = '0';
			buffer[10]++;
			if (buffer[10] > '9') buffer[10] = '0';
		}
		keySetMeta(warningKey, "warnings", &buffer[10]);
	} else  keySetMeta(warningKey, "warnings", "00");

	keySetMeta(warningKey, buffer, "number description  module file line function reason");
	strcat(buffer, "/number" );
	keySetMeta(warningKey, buffer, "C02000");
	buffer[12] = '\0'; strcat(buffer, "/description");
	keySetMeta(warningKey, buffer, "Conflict");
	buffer[12] = '\0'; strcat(buffer, "/module");
	if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
	keySetMeta(warningKey, buffer, module);
	buffer[12] = '\0'; strcat(buffer, "/file");
	keySetMeta(warningKey, buffer, file);
	buffer[12] = '\0'; strcat(buffer, "/line");
	keySetMeta(warningKey, buffer, line);
	buffer[12] = '\0'; strcat(buffer, "/mountpoint");
	keySetMeta(warningKey, buffer, keyName(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/configfile");
	keySetMeta(warningKey, buffer, keyString(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/reason");
	keySetMeta(warningKey, buffer, reason);
}

static inline void elektraSetErrorfC02000(Key *errorKey, const char *reason,
	const char *file, const char *line, const char *module, ...)  __attribute__ ((format (printf, 2, 6)));
static inline void elektraSetErrorfC02000(Key *errorKey, const char *reason,
	const char *file, const char *line, const char *module, ...)
{
	if (!errorKey) return;
	char buffer[25] = "warnings/#00";
 	const Key *meta = keyGetMeta(errorKey, "error");
	if (meta)
	{
		const Key *warningMeta = keyGetMeta(errorKey, "warnings");
		if (warningMeta)
		{
			buffer[10] = keyString(warningMeta)[0];
			buffer[11] = keyString(warningMeta)[1];
			buffer[11]++;
			if (buffer[11] > '9')
			{
				buffer[11] = '0';
				buffer[10]++;
				if (buffer[10] > '9') buffer[10] = '0';
			}
			keySetMeta(errorKey, "warnings", &buffer[10]);
		} else	keySetMeta(errorKey, "warnings", "00");
		keySetMeta(errorKey, buffer, "number description  module file line function reason");
		strcat(buffer, "/number" );
		keySetMeta(errorKey, buffer, "C02000");
		buffer[12] = '\0'; strcat(buffer, "/description");
		keySetMeta(errorKey, buffer, "Conflict");
		buffer[12] = '\0'; strcat(buffer, "/module");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, buffer, module);
		buffer[12] = '\0'; strcat(buffer, "/file");
		keySetMeta(errorKey, buffer, file);
		buffer[12] = '\0'; strcat(buffer, "/line");
		keySetMeta(errorKey, buffer, line);
		buffer[12] = '\0'; strcat(buffer, "/mountpoint");
		keySetMeta(errorKey, buffer, keyName(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/configfile");
		keySetMeta(errorKey, buffer, keyString(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/reason");
	}
 	else
 	{
		keySetMeta(errorKey, "error", "number description  module file line function reason");
		keySetMeta(errorKey, "error/number", "C02000");
		keySetMeta(errorKey, "error/description", "Conflict");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, "error/module", module);
		keySetMeta(errorKey, "error/file", file);
		keySetMeta(errorKey, "error/line", line);
		keySetMeta(errorKey, "error/mountpoint", keyName(errorKey));
		keySetMeta(errorKey, "error/configfile", keyString(errorKey));
 	}
	va_list arg;
	va_start(arg, module);
	char * r = elektraVFormat(reason, arg);
 	if (meta)
			keySetMeta(errorKey, buffer, r);
 	else
			keySetMeta(errorKey, "error/reason", r);
	elektraFree(r);
	va_end(arg);
}

static inline void elektraSetErrorC02000(Key *errorKey, const char *reason,
	const char *file, const char *line, const char *module)
{
	if (!errorKey) return;
	char buffer[25] = "warnings/#00";
 	const Key *meta = keyGetMeta(errorKey, "error");
	if (meta)
	{
		const Key *warningMeta = keyGetMeta(errorKey, "warnings");
		if (warningMeta)
		{
			buffer[10] = keyString(warningMeta)[0];
			buffer[11] = keyString(warningMeta)[1];
			buffer[11]++;
			if (buffer[11] > '9')
			{
				buffer[11] = '0';
				buffer[10]++;
				if (buffer[10] > '9') buffer[10] = '0';
			}
			keySetMeta(errorKey, "warnings", &buffer[10]);
		} else	keySetMeta(errorKey, "warnings", "00");
		keySetMeta(errorKey, buffer, "number description  module file line function reason");
		strcat(buffer, "/number" );
		keySetMeta(errorKey, buffer, "C02000");
		buffer[12] = '\0'; strcat(buffer, "/description");
		keySetMeta(errorKey, buffer, "Conflict");
		buffer[12] = '\0'; strcat(buffer, "/module");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, buffer, module);
		buffer[12] = '\0'; strcat(buffer, "/file");
		keySetMeta(errorKey, buffer, file);
		buffer[12] = '\0'; strcat(buffer, "/line");
		keySetMeta(errorKey, buffer, line);
		buffer[12] = '\0'; strcat(buffer, "/mountpoint");
		keySetMeta(errorKey, buffer, keyName(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/configfile");
		keySetMeta(errorKey, buffer, keyString(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/reason");
	}
 	else
 	{
		keySetMeta(errorKey, "error", "number description  module file line function reason");
		keySetMeta(errorKey, "error/number", "C02000");
		keySetMeta(errorKey, "error/description", "Conflict");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, "error/module", module);
		keySetMeta(errorKey, "error/file", file);
		keySetMeta(errorKey, "error/line", line);
		keySetMeta(errorKey, "error/mountpoint", keyName(errorKey));
		keySetMeta(errorKey, "error/configfile", keyString(errorKey));
 	}
 	if (meta)
			keySetMeta(errorKey, buffer, reason);
 	else
			keySetMeta(errorKey, "error/reason", reason);
}

static inline void elektraAddWarningfC03100(Key *warningKey, const char *reason,
	const char *file, const char *line, const char *module, ...)  __attribute__ ((format (printf, 2, 6)));
static inline void elektraAddWarningfC03100(Key *warningKey, const char *reason,
	const char *file, const char *line, const char *module, ...)
{
	if (!warningKey) return;

	char buffer[25] = "warnings/#00";buffer[12] = '\0';
	const Key *meta = keyGetMeta(warningKey, "warnings");
	if (meta)
	{
		buffer[10] = keyString(meta)[0];
		buffer[11] = keyString(meta)[1];
		buffer[11]++;
		if (buffer[11] > '9')
		{
			buffer[11] = '0';
			buffer[10]++;
			if (buffer[10] > '9') buffer[10] = '0';
		}
		keySetMeta(warningKey, "warnings", &buffer[10]);
	} else  keySetMeta(warningKey, "warnings", "00");

	keySetMeta(warningKey, buffer, "number description  module file line function reason");
	strcat(buffer, "/number" );
	keySetMeta(warningKey, buffer, "C03100");
	buffer[12] = '\0'; strcat(buffer, "/description");
	keySetMeta(warningKey, buffer, "Validation Syntactic");
	buffer[12] = '\0'; strcat(buffer, "/module");
	if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
	keySetMeta(warningKey, buffer, module);
	buffer[12] = '\0'; strcat(buffer, "/file");
	keySetMeta(warningKey, buffer, file);
	buffer[12] = '\0'; strcat(buffer, "/line");
	keySetMeta(warningKey, buffer, line);
	buffer[12] = '\0'; strcat(buffer, "/mountpoint");
	keySetMeta(warningKey, buffer, keyName(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/configfile");
	keySetMeta(warningKey, buffer, keyString(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/reason");
	va_list arg;
	va_start(arg, module);
	char * r = elektraVFormat(reason, arg);
	keySetMeta(warningKey, buffer, r);
	elektraFree(r);
	va_end(arg);
}

static inline void elektraAddWarningC03100(Key *warningKey, const char *reason,
	const char *file, const char *line, const char *module)
{
	if (!warningKey) return;

	char buffer[25] = "warnings/#00";buffer[12] = '\0';
	const Key *meta = keyGetMeta(warningKey, "warnings");
	if (meta)
	{
		buffer[10] = keyString(meta)[0];
		buffer[11] = keyString(meta)[1];
		buffer[11]++;
		if (buffer[11] > '9')
		{
			buffer[11] = '0';
			buffer[10]++;
			if (buffer[10] > '9') buffer[10] = '0';
		}
		keySetMeta(warningKey, "warnings", &buffer[10]);
	} else  keySetMeta(warningKey, "warnings", "00");

	keySetMeta(warningKey, buffer, "number description  module file line function reason");
	strcat(buffer, "/number" );
	keySetMeta(warningKey, buffer, "C03100");
	buffer[12] = '\0'; strcat(buffer, "/description");
	keySetMeta(warningKey, buffer, "Validation Syntactic");
	buffer[12] = '\0'; strcat(buffer, "/module");
	if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
	keySetMeta(warningKey, buffer, module);
	buffer[12] = '\0'; strcat(buffer, "/file");
	keySetMeta(warningKey, buffer, file);
	buffer[12] = '\0'; strcat(buffer, "/line");
	keySetMeta(warningKey, buffer, line);
	buffer[12] = '\0'; strcat(buffer, "/mountpoint");
	keySetMeta(warningKey, buffer, keyName(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/configfile");
	keySetMeta(warningKey, buffer, keyString(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/reason");
	keySetMeta(warningKey, buffer, reason);
}

static inline void elektraSetErrorfC03100(Key *errorKey, const char *reason,
	const char *file, const char *line, const char *module, ...)  __attribute__ ((format (printf, 2, 6)));
static inline void elektraSetErrorfC03100(Key *errorKey, const char *reason,
	const char *file, const char *line, const char *module, ...)
{
	if (!errorKey) return;
	char buffer[25] = "warnings/#00";
 	const Key *meta = keyGetMeta(errorKey, "error");
	if (meta)
	{
		const Key *warningMeta = keyGetMeta(errorKey, "warnings");
		if (warningMeta)
		{
			buffer[10] = keyString(warningMeta)[0];
			buffer[11] = keyString(warningMeta)[1];
			buffer[11]++;
			if (buffer[11] > '9')
			{
				buffer[11] = '0';
				buffer[10]++;
				if (buffer[10] > '9') buffer[10] = '0';
			}
			keySetMeta(errorKey, "warnings", &buffer[10]);
		} else	keySetMeta(errorKey, "warnings", "00");
		keySetMeta(errorKey, buffer, "number description  module file line function reason");
		strcat(buffer, "/number" );
		keySetMeta(errorKey, buffer, "C03100");
		buffer[12] = '\0'; strcat(buffer, "/description");
		keySetMeta(errorKey, buffer, "Validation Syntactic");
		buffer[12] = '\0'; strcat(buffer, "/module");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, buffer, module);
		buffer[12] = '\0'; strcat(buffer, "/file");
		keySetMeta(errorKey, buffer, file);
		buffer[12] = '\0'; strcat(buffer, "/line");
		keySetMeta(errorKey, buffer, line);
		buffer[12] = '\0'; strcat(buffer, "/mountpoint");
		keySetMeta(errorKey, buffer, keyName(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/configfile");
		keySetMeta(errorKey, buffer, keyString(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/reason");
	}
 	else
 	{
		keySetMeta(errorKey, "error", "number description  module file line function reason");
		keySetMeta(errorKey, "error/number", "C03100");
		keySetMeta(errorKey, "error/description", "Validation Syntactic");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, "error/module", module);
		keySetMeta(errorKey, "error/file", file);
		keySetMeta(errorKey, "error/line", line);
		keySetMeta(errorKey, "error/mountpoint", keyName(errorKey));
		keySetMeta(errorKey, "error/configfile", keyString(errorKey));
 	}
	va_list arg;
	va_start(arg, module);
	char * r = elektraVFormat(reason, arg);
 	if (meta)
			keySetMeta(errorKey, buffer, r);
 	else
			keySetMeta(errorKey, "error/reason", r);
	elektraFree(r);
	va_end(arg);
}

static inline void elektraSetErrorC03100(Key *errorKey, const char *reason,
	const char *file, const char *line, const char *module)
{
	if (!errorKey) return;
	char buffer[25] = "warnings/#00";
 	const Key *meta = keyGetMeta(errorKey, "error");
	if (meta)
	{
		const Key *warningMeta = keyGetMeta(errorKey, "warnings");
		if (warningMeta)
		{
			buffer[10] = keyString(warningMeta)[0];
			buffer[11] = keyString(warningMeta)[1];
			buffer[11]++;
			if (buffer[11] > '9')
			{
				buffer[11] = '0';
				buffer[10]++;
				if (buffer[10] > '9') buffer[10] = '0';
			}
			keySetMeta(errorKey, "warnings", &buffer[10]);
		} else	keySetMeta(errorKey, "warnings", "00");
		keySetMeta(errorKey, buffer, "number description  module file line function reason");
		strcat(buffer, "/number" );
		keySetMeta(errorKey, buffer, "C03100");
		buffer[12] = '\0'; strcat(buffer, "/description");
		keySetMeta(errorKey, buffer, "Validation Syntactic");
		buffer[12] = '\0'; strcat(buffer, "/module");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, buffer, module);
		buffer[12] = '\0'; strcat(buffer, "/file");
		keySetMeta(errorKey, buffer, file);
		buffer[12] = '\0'; strcat(buffer, "/line");
		keySetMeta(errorKey, buffer, line);
		buffer[12] = '\0'; strcat(buffer, "/mountpoint");
		keySetMeta(errorKey, buffer, keyName(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/configfile");
		keySetMeta(errorKey, buffer, keyString(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/reason");
	}
 	else
 	{
		keySetMeta(errorKey, "error", "number description  module file line function reason");
		keySetMeta(errorKey, "error/number", "C03100");
		keySetMeta(errorKey, "error/description", "Validation Syntactic");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, "error/module", module);
		keySetMeta(errorKey, "error/file", file);
		keySetMeta(errorKey, "error/line", line);
		keySetMeta(errorKey, "error/mountpoint", keyName(errorKey));
		keySetMeta(errorKey, "error/configfile", keyString(errorKey));
 	}
 	if (meta)
			keySetMeta(errorKey, buffer, reason);
 	else
			keySetMeta(errorKey, "error/reason", reason);
}

static inline void elektraAddWarningfC03200(Key *warningKey, const char *reason,
	const char *file, const char *line, const char *module, ...)  __attribute__ ((format (printf, 2, 6)));
static inline void elektraAddWarningfC03200(Key *warningKey, const char *reason,
	const char *file, const char *line, const char *module, ...)
{
	if (!warningKey) return;

	char buffer[25] = "warnings/#00";buffer[12] = '\0';
	const Key *meta = keyGetMeta(warningKey, "warnings");
	if (meta)
	{
		buffer[10] = keyString(meta)[0];
		buffer[11] = keyString(meta)[1];
		buffer[11]++;
		if (buffer[11] > '9')
		{
			buffer[11] = '0';
			buffer[10]++;
			if (buffer[10] > '9') buffer[10] = '0';
		}
		keySetMeta(warningKey, "warnings", &buffer[10]);
	} else  keySetMeta(warningKey, "warnings", "00");

	keySetMeta(warningKey, buffer, "number description  module file line function reason");
	strcat(buffer, "/number" );
	keySetMeta(warningKey, buffer, "C03200");
	buffer[12] = '\0'; strcat(buffer, "/description");
	keySetMeta(warningKey, buffer, "Validation Semantic");
	buffer[12] = '\0'; strcat(buffer, "/module");
	if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
	keySetMeta(warningKey, buffer, module);
	buffer[12] = '\0'; strcat(buffer, "/file");
	keySetMeta(warningKey, buffer, file);
	buffer[12] = '\0'; strcat(buffer, "/line");
	keySetMeta(warningKey, buffer, line);
	buffer[12] = '\0'; strcat(buffer, "/mountpoint");
	keySetMeta(warningKey, buffer, keyName(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/configfile");
	keySetMeta(warningKey, buffer, keyString(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/reason");
	va_list arg;
	va_start(arg, module);
	char * r = elektraVFormat(reason, arg);
	keySetMeta(warningKey, buffer, r);
	elektraFree(r);
	va_end(arg);
}

static inline void elektraAddWarningC03200(Key *warningKey, const char *reason,
	const char *file, const char *line, const char *module)
{
	if (!warningKey) return;

	char buffer[25] = "warnings/#00";buffer[12] = '\0';
	const Key *meta = keyGetMeta(warningKey, "warnings");
	if (meta)
	{
		buffer[10] = keyString(meta)[0];
		buffer[11] = keyString(meta)[1];
		buffer[11]++;
		if (buffer[11] > '9')
		{
			buffer[11] = '0';
			buffer[10]++;
			if (buffer[10] > '9') buffer[10] = '0';
		}
		keySetMeta(warningKey, "warnings", &buffer[10]);
	} else  keySetMeta(warningKey, "warnings", "00");

	keySetMeta(warningKey, buffer, "number description  module file line function reason");
	strcat(buffer, "/number" );
	keySetMeta(warningKey, buffer, "C03200");
	buffer[12] = '\0'; strcat(buffer, "/description");
	keySetMeta(warningKey, buffer, "Validation Semantic");
	buffer[12] = '\0'; strcat(buffer, "/module");
	if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
	keySetMeta(warningKey, buffer, module);
	buffer[12] = '\0'; strcat(buffer, "/file");
	keySetMeta(warningKey, buffer, file);
	buffer[12] = '\0'; strcat(buffer, "/line");
	keySetMeta(warningKey, buffer, line);
	buffer[12] = '\0'; strcat(buffer, "/mountpoint");
	keySetMeta(warningKey, buffer, keyName(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/configfile");
	keySetMeta(warningKey, buffer, keyString(warningKey));
	buffer[12] = '\0'; strcat(buffer, "/reason");
	keySetMeta(warningKey, buffer, reason);
}

static inline void elektraSetErrorfC03200(Key *errorKey, const char *reason,
	const char *file, const char *line, const char *module, ...)  __attribute__ ((format (printf, 2, 6)));
static inline void elektraSetErrorfC03200(Key *errorKey, const char *reason,
	const char *file, const char *line, const char *module, ...)
{
	if (!errorKey) return;
	char buffer[25] = "warnings/#00";
 	const Key *meta = keyGetMeta(errorKey, "error");
	if (meta)
	{
		const Key *warningMeta = keyGetMeta(errorKey, "warnings");
		if (warningMeta)
		{
			buffer[10] = keyString(warningMeta)[0];
			buffer[11] = keyString(warningMeta)[1];
			buffer[11]++;
			if (buffer[11] > '9')
			{
				buffer[11] = '0';
				buffer[10]++;
				if (buffer[10] > '9') buffer[10] = '0';
			}
			keySetMeta(errorKey, "warnings", &buffer[10]);
		} else	keySetMeta(errorKey, "warnings", "00");
		keySetMeta(errorKey, buffer, "number description  module file line function reason");
		strcat(buffer, "/number" );
		keySetMeta(errorKey, buffer, "C03200");
		buffer[12] = '\0'; strcat(buffer, "/description");
		keySetMeta(errorKey, buffer, "Validation Semantic");
		buffer[12] = '\0'; strcat(buffer, "/module");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, buffer, module);
		buffer[12] = '\0'; strcat(buffer, "/file");
		keySetMeta(errorKey, buffer, file);
		buffer[12] = '\0'; strcat(buffer, "/line");
		keySetMeta(errorKey, buffer, line);
		buffer[12] = '\0'; strcat(buffer, "/mountpoint");
		keySetMeta(errorKey, buffer, keyName(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/configfile");
		keySetMeta(errorKey, buffer, keyString(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/reason");
	}
 	else
 	{
		keySetMeta(errorKey, "error", "number description  module file line function reason");
		keySetMeta(errorKey, "error/number", "C03200");
		keySetMeta(errorKey, "error/description", "Validation Semantic");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, "error/module", module);
		keySetMeta(errorKey, "error/file", file);
		keySetMeta(errorKey, "error/line", line);
		keySetMeta(errorKey, "error/mountpoint", keyName(errorKey));
		keySetMeta(errorKey, "error/configfile", keyString(errorKey));
 	}
	va_list arg;
	va_start(arg, module);
	char * r = elektraVFormat(reason, arg);
 	if (meta)
			keySetMeta(errorKey, buffer, r);
 	else
			keySetMeta(errorKey, "error/reason", r);
	elektraFree(r);
	va_end(arg);
}

static inline void elektraSetErrorC03200(Key *errorKey, const char *reason,
	const char *file, const char *line, const char *module)
{
	if (!errorKey) return;
	char buffer[25] = "warnings/#00";
 	const Key *meta = keyGetMeta(errorKey, "error");
	if (meta)
	{
		const Key *warningMeta = keyGetMeta(errorKey, "warnings");
		if (warningMeta)
		{
			buffer[10] = keyString(warningMeta)[0];
			buffer[11] = keyString(warningMeta)[1];
			buffer[11]++;
			if (buffer[11] > '9')
			{
				buffer[11] = '0';
				buffer[10]++;
				if (buffer[10] > '9') buffer[10] = '0';
			}
			keySetMeta(errorKey, "warnings", &buffer[10]);
		} else	keySetMeta(errorKey, "warnings", "00");
		keySetMeta(errorKey, buffer, "number description  module file line function reason");
		strcat(buffer, "/number" );
		keySetMeta(errorKey, buffer, "C03200");
		buffer[12] = '\0'; strcat(buffer, "/description");
		keySetMeta(errorKey, buffer, "Validation Semantic");
		buffer[12] = '\0'; strcat(buffer, "/module");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, buffer, module);
		buffer[12] = '\0'; strcat(buffer, "/file");
		keySetMeta(errorKey, buffer, file);
		buffer[12] = '\0'; strcat(buffer, "/line");
		keySetMeta(errorKey, buffer, line);
		buffer[12] = '\0'; strcat(buffer, "/mountpoint");
		keySetMeta(errorKey, buffer, keyName(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/configfile");
		keySetMeta(errorKey, buffer, keyString(errorKey));
		buffer[12] = '\0'; strcat(buffer, "/reason");
	}
 	else
 	{
		keySetMeta(errorKey, "error", "number description  module file line function reason");
		keySetMeta(errorKey, "error/number", "C03200");
		keySetMeta(errorKey, "error/description", "Validation Semantic");
		if (strcmp(module, "ELEKTRA_MODULE_NAME") == 0) module = "kdb";
		keySetMeta(errorKey, "error/module", module);
		keySetMeta(errorKey, "error/file", file);
		keySetMeta(errorKey, "error/line", line);
		keySetMeta(errorKey, "error/mountpoint", keyName(errorKey));
		keySetMeta(errorKey, "error/configfile", keyString(errorKey));
 	}
 	if (meta)
			keySetMeta(errorKey, buffer, reason);
 	else
			keySetMeta(errorKey, "error/reason", reason);
}

static inline KeySet *elektraErrorSpecification (void)
{
	return ksNew (30,
		keyNew ("system/elektra/modules/error/specification",
			KEY_VALUE, "the specification of all error codes", KEY_END),
		keyNew ("system/elektra/modules/error/specification/C01100",
			KEY_END),
		keyNew ("system/elektra/modules/error/specification/C01100/description",
			KEY_VALUE, "Resource", KEY_END),
		keyNew ("system/elektra/modules/error/specification/C01110",
			KEY_END),
		keyNew ("system/elektra/modules/error/specification/C01110/description",
			KEY_VALUE, "Out of Memory", KEY_END),
		keyNew ("system/elektra/modules/error/specification/C01200",
			KEY_END),
		keyNew ("system/elektra/modules/error/specification/C01200/description",
			KEY_VALUE, "Installation", KEY_END),
		keyNew ("system/elektra/modules/error/specification/C01310",
			KEY_END),
		keyNew ("system/elektra/modules/error/specification/C01310/description",
			KEY_VALUE, "Internal", KEY_END),
		keyNew ("system/elektra/modules/error/specification/C01320",
			KEY_END),
		keyNew ("system/elektra/modules/error/specification/C01320/description",
			KEY_VALUE, "Interface", KEY_END),
		keyNew ("system/elektra/modules/error/specification/C01330",
			KEY_END),
		keyNew ("system/elektra/modules/error/specification/C01330/description",
			KEY_VALUE, "Plugin Misbehavior", KEY_END),
		keyNew ("system/elektra/modules/error/specification/C02000",
			KEY_END),
		keyNew ("system/elektra/modules/error/specification/C02000/description",
			KEY_VALUE, "Conflict", KEY_END),
		keyNew ("system/elektra/modules/error/specification/C03100",
			KEY_END),
		keyNew ("system/elektra/modules/error/specification/C03100/description",
			KEY_VALUE, "Validation Syntactic", KEY_END),
		keyNew ("system/elektra/modules/error/specification/C03200",
			KEY_END),
		keyNew ("system/elektra/modules/error/specification/C03200/description",
			KEY_VALUE, "Validation Semantic", KEY_END),
		KS_END);
}
static inline void elektraTriggerWarnings (const char *nr, Key *parentKey, const char *message)
{
	if (strcmp(nr, "C01100") == 0)
	{
		ELEKTRA_ADD_RESOURCE_WARNING (parentKey, message);
		return;
	}
	if (strcmp(nr, "C01110") == 0)
	{
		ELEKTRA_ADD_OUT_OF_MEMORY_WARNING (parentKey, message);
		return;
	}
	if (strcmp(nr, "C01200") == 0)
	{
		ELEKTRA_ADD_INSTALLATION_WARNING (parentKey, message);
		return;
	}
	if (strcmp(nr, "C01310") == 0)
	{
		ELEKTRA_ADD_INTERNAL_WARNING (parentKey, message);
		return;
	}
	if (strcmp(nr, "C01320") == 0)
	{
		ELEKTRA_ADD_INTERFACE_WARNING (parentKey, message);
		return;
	}
	if (strcmp(nr, "C01330") == 0)
	{
		ELEKTRA_ADD_PLUGIN_MISBEHAVIOR_WARNING (parentKey, message);
		return;
	}
	if (strcmp(nr, "C02000") == 0)
	{
		ELEKTRA_ADD_CONFLICTING_STATE_WARNING (parentKey, message);
		return;
	}
	if (strcmp(nr, "C03100") == 0)
	{
		ELEKTRA_ADD_VALIDATION_SYNTACTIC_WARNING (parentKey, message);
		return;
	}
	if (strcmp(nr, "C03200") == 0)
	{
		ELEKTRA_ADD_VALIDATION_SEMANTIC_WARNING (parentKey, message);
		return;
	}
	ELEKTRA_ADD_INTERNAL_WARNINGF (parentKey, "Unkown warning code %s", nr);
}

static inline void elektraTriggerError (const char *nr, Key *parentKey, const char *message)
{
	if (strcmp(nr, "C01100") == 0)
	{
		ELEKTRA_SET_RESOURCE_ERROR (parentKey, message);
		return;
	}
	if (strcmp(nr, "C01110") == 0)
	{
		ELEKTRA_SET_OUT_OF_MEMORY_ERROR (parentKey, message);
		return;
	}
	if (strcmp(nr, "C01200") == 0)
	{
		ELEKTRA_SET_INSTALLATION_ERROR (parentKey, message);
		return;
	}
	if (strcmp(nr, "C01310") == 0)
	{
		ELEKTRA_SET_INTERNAL_ERROR (parentKey, message);
		return;
	}
	if (strcmp(nr, "C01320") == 0)
	{
		ELEKTRA_SET_INTERFACE_ERROR (parentKey, message);
		return;
	}
	if (strcmp(nr, "C01330") == 0)
	{
		ELEKTRA_SET_PLUGIN_MISBEHAVIOR_ERROR (parentKey, message);
		return;
	}
	if (strcmp(nr, "C02000") == 0)
	{
		ELEKTRA_SET_CONFLICTING_STATE_ERROR (parentKey, message);
		return;
	}
	if (strcmp(nr, "C03100") == 0)
	{
		ELEKTRA_SET_VALIDATION_SYNTACTIC_ERROR (parentKey, message);
		return;
	}
	if (strcmp(nr, "C03200") == 0)
	{
		ELEKTRA_SET_VALIDATION_SEMANTIC_ERROR (parentKey, message);
		return;
	}
	ELEKTRA_SET_INTERNAL_ERRORF (parentKey, "Unkown error code %s", nr);
}
#endif
