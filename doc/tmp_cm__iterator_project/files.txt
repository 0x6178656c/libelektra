# Functions to be removed
ksRewind
ksNext
ksCurrent

ksGetCursor
ksSetCursor

keyRewindMeta
keyNextMeta
keyCurrentMeta

ksHead
ksTail


## End goal:
IMO, the end goal would be to remove Key * cursor and size_t current from struct _KeySet.



# Existing functions (already available)
ksSearch: can be used to obtain the index of a key in a keyset
ksAtCursor: get the Key at a given index (to be renamed to ksAt)
ksPop: is going to get replaced by elektraKsPopAtCursor
keyMeta: get a keyset meta metakeys of a key


# Track the work progress per file and line.
* ... in progress
> ... finished
< ... Nothing to change (e.g. historical reports)
X ... blocked (explain!)
+ ... added (dependency of change in other file)
? ... open questions



grep -cir -- "ksRewind\|ksNext\|ksCurrent\|ksGetCursor\|ksSetCursor\|keyRewindMeta\|keyNextMeta\|keyCurrentMeta\|ksHead\|ksTail" * | grep -v ':0$' | nl

# Benchmarks
>     1	benchmarks/storage.c:6
>58:	ksRewind (ks);
>60:	while ((cur = ksNext (ks)))
>68:	ksRewind (ks);
>72:	while ((cur = ksNext (ks)))
>81:	ksRewind (ks);
>85:	while ((cur = ksNext (ks)))

>     2	benchmarks/opmphm.c:8
>99:				ksRewind (ks);
>106:				while ((key = ksNext (ks)))
>1569:		ksRewind (ks);
>1589:		while ((key = ksNext (ks)))
>1608:		ksRewind (ks);
>1609:		while ((key = ksNext (ks)))
>2086:			ksRewind (ks);
>2087:			while ((key = ksNext (ks)))


>     3	benchmarks/createkeys.c:2
>18:	ksRewind (large);
>21:	while ((cur = ksNext (large)))

# Documentation
    
	## Reports of historical reviews (not to update)
<	 4	doc/api_review/core/ksAtCursor.md:2
<     5	doc/api_review/core/keyRewindMeta.md:3
<     6	doc/api_review/core/ksTail.md:4
<     7	doc/api_review/core/keyCurrentMeta.md:3
<     8	doc/api_review/core/keyNextMeta.md:4
<     9	doc/api_review/core/ksHead.md:4
<    10	doc/api_review/core/ksSetCursor.md:4
<    11	doc/api_review/core/ksGetCursor.md:2
<    12	doc/api_review/core/ksPop.md:1
<    13	doc/api_review/core/ksCurrent.md:2
<    14	doc/api_review/core/ksRewind.md:2
<    15	doc/api_review/core/ksNext.md:2


>    16	doc/tutorials/plugins.md:2
>409:	ksRewind (conf);
>410:	while ((cur = ksNext (conf)) != 0)



< Nothing to change --> talks already about ksNext becoming deprecated
<    17	doc/API.md:1
<114:- [Work with](@ref ksNext) its [internal cursor](@ref ksCurrent)

## Historic news are not changed
<    18	doc/news/2014-09-02_0.8.8.md:1
<    19	doc/news/2021-04-12_0.9.5.md:6


<   20	doc/VERSION.md:1
< 122:For example, in `1.0` there is a deprecated method `ksNext` (not

? Ask what this is about!
?    21	doc/todo/TODO:1
? 101:	ksCurrent only for iterator


X Missing test cases for iterator interface mentioned --> implement test
X cases for usage of external iterator and remove in doc after that
X    22	doc/todo/TESTING:1
X 184:ksNext should be safe to missusage?


? Ask if we should edit the file to mention changes we made?
?    23	doc/decisions/simplify_api.md:1
? 39:- _Remove_ all functions related to keyset cursors, as well as `ksHead` and `ksTail`


? This file basically describes a part of our CM-project
? Ask if we should edit the file to mention changes we made?
?	24	doc/decisions/iterators.md:12



? Ask if we should update to document?
? It mentions the version 0.8, so should we change this part too?
? 64: This subsection describes what has changed between 0.7 and 0.8 and deals with
? 65: some general implementation issues.
? 
?
? 25	doc/dev/data-structures.md:4
? 202:`ksRewind()` to go to the beginning and `ksNext()` to
? 237:`ksGetCursor()` and `ksSetCursor()`.
? 251:`ksNext()`.
? 257:faster than using the internal cursor with ksNext().


> Added new example for ussage, rewrote some text
>    26	doc/dev/metadata.md:3
> 71:int keyRewindMeta(Key *key);
> 72:const Key *keyNextMeta(Key *key);
> 73:const Key *keyCurrentMeta(const Key *key);
>






# Examples

>    27	examples/keyMetaKeySet.c:2
> 25:	ksRewind (keyMeta (key));
> 26:	while ((cur = ksNext (keyMeta (key))) != NULL)


>    28	examples/ksLookupPop.c:2
> 17:	ksRewind (iterator);
> 18:	while ((current = ksNext (iterator)))


>    29	examples/iterate.c:10
> 15: * elektra. We use ksNext() and keyIsBelow() to implement a function
> 17:Key * ksNextDir (KeySet * ks)
> 20:	Key * startKey = ksCurrent (ks);
> 22:	if (!startKey) return (ksNext (ks));
> 24:	while ((cur = ksNext (ks)) != 0)
> 50:	ksRewind (ks);
> 51:	while ((cur = ksNext (ks)) != 0)
> 57:	ksRewind (ks);
> 58:	while ((cur = ksNextDir (ks)) != 0)
> 66:	while ((cur = ksNext (ks)) != 0)


>	Internal iterator was only used on commented out code -> removed the comment
>    30	examples/external/pkgconfig/application.c:2
> 28:	ksRewind(myConfig);
> 29:	while ((key = ksNext(myConfig)))


>    31	examples/gopts.c:2
> 231:	ksRewind (files);
> 233:	while ((cur = ksNext (files)) != NULL)


>    32	examples/cascading.c:2
> 42:	ksRewind (ks);
> 44:	while ((k = ksNext (ks)))


> Changes to a function that is never called (TODO: test it!)
>    33	examples/kdbget_error.c:2
> 111:	keyRewindMeta (key);
> 112:	while ((iter_key = keyNextMeta (key)) != 0)


>    34	examples/optsCommands.c:3
> 158:			ksRewind (dynamicCommand);
> 159:			printf ("%s' with arguments:", keyString (ksNext (dynamicCommand)));
> 161:			while ((cur = ksNext (dynamicCommand)) != NULL)


>    35	examples/ksNewExample.c:2
> 23: ksRewind (myConfig);
> 24: while ((current = ksNext (myConfig)) != 0)


>    36	examples/set_key.c:2
> 23:	keyRewindMeta (err);
> 24:	while ((meta = keyNextMeta (err)) != 0)


>    37	examples/goptsCommands.c:3
> 224:			ksRewind (dynamicCommand);
> 225:			printf ("%s' with arguments:", keyString (ksNext (dynamicCommand)));
> 227:			while ((cur = ksNext (dynamicCommand)) != NULL)


    38	examples/functional.c:13
?? Position where execution stopped now no longer available via ksCurrent()
?? Should we change the return value or emmit an error or ...
ksForEach:
> 29: * 	ksCurrent() will tell you where it stopped.
> 37:	elektraCursor cursor = ksGetCursor (ks);
> 38:	ksRewind (ks);
> 39:	while ((current = ksNext (ks)) != 0)
> 45:	ksSetCursor (ks, cursor);

ksFilter:
?? Same problem, in case of error the position of the problematic key can no
?? longer be retrieved via ksCurrent()
> 54: * when it returns -1 the processing will be stopped. You can use ksCurrent()
> 56: * apart from ksCurrent() the input will not be changed. The keys that have
> 65: * @retval -1 when filter returned an error (-1), ksCurrent() of input will
> 74:	elektraCursor cursor = ksGetCursor (input);
> 75:	ksRewind (input);
> 76:	while ((current = ksNext (input)) != 0)
> 87:	ksSetCursor (input, cursor);
> 172:	ksCurrent (values);		      /* here is user:/c */


>    39	examples/keyMeta.c:2
> 37:	ksRewind (ks);
> 38:	while ((current = ksNext (ks)) != 0)


>     40	examples/keyset.c:3
> 90:	printf ("A duplication was appended in keyset with name %s\n", keyName (ksHead (ks)));
> 102:	ksRewind (ks);
> 103:	origKey = ksNext (ks);


>     41	examples/ksCut.c:3
> 15:	ksRewind (returned);
> 16:	while (ksNext (returned))
> 18:		printf ("%s\n", keyName (ksCurrent (returned)));


>    42	examples/meta.c:2
> 52:	keyRewindMeta (k);
> 53:	while ((meta = keyNextMeta (k)) != 0)


>    43	examples/opts.c:2
> 165:	ksRewind (files);
> 167:	while ((cur = ksNext (files)) != NULL)


# Scripts

> Removed obsolete functions from file
>     44	scripts/api_review/methods.c.txt:10
> 15:int keyRewindMeta(Key *key);
> 16:const Key *keyNextMeta(Key *key);
> 17:const Key *keyCurrentMeta(const Key *key);
> 65:int ksRewind(KeySet *ks);
> 66:Key *ksNext(KeySet *ks);
> 67:Key *ksCurrent(const KeySet *ks);
> 68:Key *ksHead(const KeySet *ks);
> 69:Key *ksTail(const KeySet *ks);
> 70:elektraCursor ksGetCursor(const KeySet *ks);
> 71:int ksSetCursor(KeySet *ks, elektraCursor cursor);




# Plugins

>     45	src/plugins/ni/ni.c:7
> 75:	keyRewindMeta (cur);
> 76:	while ((m = keyNextMeta (cur)) != 0)
> 91:	ksRewind (returned);
> 93:	if (keyCmp (ksHead (returned), parentKey) == 0)
> 97:		keyMetaToNi (add, ksHead (returned));
> 98:		ksNext (returned); // do not process parent in loop again
> 101:	while ((cur = ksNext (returned)) != 0)


>    46	src/plugins/gpgme/gpgme.c:6
> 178:		ksRewind (config);
> 179:		while ((k = ksNext (config)) != 0)
> 378:	ksRewind (data);
> 379:	while ((k = ksNext (data)))
> 492:	ksRewind (data);
> 493:	while ((k = ksNext (data)) != 0)


>    47	src/plugins/length/test_length.h:6
> 40:	ksRewind (ks);
> 47:	ksRewind (ks);
> 54:	ksRewind (ks);
> 61:	ksRewind (ks);
> 68:	ksRewind (ks);
> 73:	ksRewind (ks);


>     48	src/plugins/length/length.c:4
> 67:	ksRewind (returned);
> 68:	while ((cur = ksNext (returned)) != NULL)
> 83:	ksRewind (returned);
> 84:	while ((cur = ksNext (returned)) != NULL)


>    49	src/plugins/keytometa/keytometa.c:6
> 52:	ksSetCursor (ks, ksGetSize (ks) - 1);
> 54:	for (elektraCursor cursor = ksGetCursor (ks) - 1; (current = ksAtCursor (ks, cursor)) != NULL; --cursor)
> 130:	ksRewind (converted);
> 133:	while ((current = ksNext (converted)))
> 289:	ksRewind (converted);
> 295:	while ((current = ksNext (converted)) != 0)


>    50	src/plugins/path/path.c:2
> 370:	ksRewind (returned);
> 372:	while ((cur = ksNext (returned)) != 0)


>    51	src/plugins/multifile/multifile.c:26
> 192:	ksRewind (b);
> 194:	while ((k = ksNext (b)) != NULL)
updateFiles:
> 420:	ksRewind (mc->childBackends);
> 421:	ksRewind (found);
> 425:	while ((c = ksNext (found)) != NULL)
> 440:					elektraCursor savedCursor = ksGetCursor (found);
> 442:					ksSetCursor (found, savedCursor);
doGetStorage:
> 490:	ksRewind (mc->childBackends);
> 494:	while ((k = ksNext (mc->childBackends)) != NULL)
fillReturned:
> 525:	ksRewind (mc->childBackends);
> 528:	while ((k = ksNext (mc->childBackends)) != NULL)
> 533:	ksRewind (returned);
resolverSet:
> 611:	ksRewind (mc->childBackends);
> 615:	while ((k = ksNext (mc->childBackends)) != NULL)
doGetStorage:
> 652:	ksRewind (mc->childBackends);
> 656:	while ((k = ksNext (mc->childBackends)) != NULL)
doCommit:
> 688:	ksRewind (mc->childBackends);
> 692:	while ((k = ksNext (mc->childBackends)) != NULL)
diffOrNeedSync:
> 722:	ksRewind (ks);
> 723:	ksRewind (checkKS);
> 729:		key = ksNext (ks);
> 730:		check = ksNext (checkKS);
flagUpdateBackends
> 753:	ksRewind (mc->childBackends);
> 755:	while ((k = ksNext (mc->childBackends)) != NULL)
elektraMultifileError
> 829:	ksRewind (mc->childBackends);
> 832:	while ((key = ksNext (mc->childBackends)) != NULL)


>    52	src/plugins/c/c.c:4
> 134:	keyRewindMeta (dup);
> 135:	while ((meta = keyNextMeta (dup)))
> 166:	ksRewind (cks);
> 169:	while ((key = ksNext (cks)) != 0)


>    53	src/plugins/base64/base64.c:4
> 252:	ksRewind (keySet);
> 254:	while (status >= 0 && (key = ksNext (keySet)))
> 276:	ksRewind (keySet);
> 281:	while (status >= 0 && (key = ksNext (keySet)))


>    54	src/plugins/glob/glob.c:7
> 103:	while ((k = ksNext (keys)) != 0)
> 142:	ksRewind (returned);
> 143:	while ((cur = ksNext (returned)) != 0)
> 146:		ksRewind (glob);
> 147:		while ((match = ksNext (glob)) != 0)
> 200:	ksRewind (keys);
> 214:	ksRewind (keys);


>    55	src/plugins/date/date.c:2
> 478:	while ((cur = ksNext (returned)) != NULL)
> 499:	while ((cur = ksNext (returned)) != NULL)


>    56	src/plugins/range/range.c:2
> 521:	while ((cur = ksNext (returned)) != NULL)
> 543:	while ((cur = ksNext (returned)) != NULL)


>    57	src/plugins/range/testmod_range.c:5
> 26:	ksRewind (ks);
> 44:	ksRewind (ks);
> 62:	ksRewind (ks);
> 80:	ksRewind (ks);
> 98:	ksRewind (ks);


>    58	src/plugins/python/testmod_python.c:1
> 37:	succeed_if_same_string (keyName (ksHead (ks)), "user:/from_python");


>    59	src/plugins/type/types.c:2
> 304:	ksRewind (validValues);
> 306:	while ((cur = ksNext (validValues)) != NULL)


>    60	src/plugins/type/testmod_type.c:2
> 364:	ksRewind (ks);
> 371:	ksRewind (ks);


>    61	src/plugins/type/type.c:16
elektraTypeGet:
> 301:	elektraCursor cursor = ksGetCursor (returned);
> 303:	ksRewind (returned);
> 306:	while ((cur = ksNext (returned)))
> 318:			ksSetCursor (returned, cursor);
> 332:				ksSetCursor (returned, cursor);
> 341:				ksSetCursor (returned, cursor);
> 349:			ksSetCursor (returned, cursor);
> 354:	ksSetCursor (returned, cursor);
elektraTypeSet:
> 361:	elektraCursor cursor = ksGetCursor (returned);
> 363:	ksRewind (returned);
> 366:	while ((cur = ksNext (returned)))
> 378:			ksSetCursor (returned, cursor);
> 391:				ksSetCursor (returned, cursor);
> 399:			ksSetCursor (returned, cursor);
> 408:			ksSetCursor (returned, cursor);
> 413:	ksSetCursor (returned, cursor);


>    62	src/plugins/hosts/hosts-set.c:4
> 66:	ksRewind (comments);
> 68:	while ((current = ksNext (comments)))
> 107:	while ((alias = ksNext (returned)) != 0)
> 134:	ksRewind (returned);


    63	src/plugins/hosts/hosts-get.c:4
> 191:	elektraCursor initialCursor = ksGetCursor (metaKeySet);
> 192:	ksRewind (metaKeySet);
> 193:	while ((currentMeta = ksNext (metaKeySet)))
> 198:	ksSetCursor (metaKeySet, initialCursor);



>    64	src/plugins/validation/validation.c:1
> 178:	while ((cur = ksNext (returned)) != 0)


>    65	src/plugins/validation/lookupre.c:2
> 47:ksRewind(ks);
> 89:	while ((walker = ksNext (ks)) != end)


>    66	src/plugins/validation/testmod_validation.c:16
> 47:	ksRewind (ks);
> 73:	ksRewind (ks);
> 107:	ksRewind (ks);
> 113:	ksRewind (ks);
> 119:	ksRewind (ks);
> 125:	ksRewind (ks);
> 151:	ksRewind (ks);
> 157:	ksRewind (ks);
> 163:	ksRewind (ks);
> 169:	ksRewind (ks);
> 195:	ksRewind (ks);
> 201:	ksRewind (ks);
> 207:	ksRewind (ks);
> 213:	ksRewind (ks);
> 235:	ksRewind (ks);
> 241:	ksRewind (ks);


>    67	src/plugins/internalnotification/internalnotification.c:2
> 232:	ksRewind (ks);
> 233:	while ((current = ksNext (ks)) != NULL)


>    68	src/plugins/csvstorage/csvstorage.c:18
csvRead:
> 400:	ksRewind (header);
> 425:		ksRewind (header);
> 429:			cur = ksNext (header);
> 460:				ksRewind (tmpKs);
> 463:				ksRewind (renamedKs);
> 466:				ksRewind (renamedKs);
> 467:				ksRewind (tmpKs);
elektraCsvstorageGet:
> 580:				while ((cur = ksNext (namesKS)) != NULL)
csvWrite:
> 637:	ksRewind (returned);
> 638:	while ((cur = ksNext (returned)) != NULL)
> 650:			ksRewind (tmpKs);
> 652:			ksRewind (headerKs);
> 654:			ksNext (headerKs);
> 655:			Key * tmp = ksNext (headerKs);
> 663:			while ((tmp = ksNext (headerKs)) != NULL)
> 688:		ksRewind (toWriteKS);
> 692:			toWrite = ksNext (toWriteKS);
elektraCsvstorageSet:
> 759:		ksRewind (exportKS);


>    69	src/plugins/ruby/testmod_ruby.c:10
> 107:	Key * head = ksHead (ks);
> 108:	Key * tail = ksTail (ks);
> 132:	Key * head = ksHead (ks);
> 133:	Key * tail = ksTail (ks);
> 196:	Key * head = ksHead (ksGet);
> 197:	Key * tail = ksTail (ksGet);
> 236:	Key * head1 = ksHead (ksGet1);
> 237:	Key * tail1 = ksTail (ksGet1);
> 255:	Key * head2 = ksHead (ksGet2);
> 256:	Key * tail2 = ksTail (ksGet2);


>    70	src/plugins/profile/profile.c:14
linkProfileKeys:
> 87:	ksRewind (profileKeys);
> 88:	while ((profileKey = ksNext (profileKeys)) != NULL)
> 99:			ksRewind (profileKS);
> 101:			while ((cur = ksNext (profileKS)) != NULL)
linkDefaultKeys:
> 130:	ksRewind (profileParents);
> 132:	while ((profileParent = ksNext (profileParents)) != NULL)
> 137:		ksRewind (defaultKS);
> 141:		while ((cur = ksNext (defaultKS)) != NULL)
elektraProfileGet:
> 190:	ksRewind (swKS);
> 196:	while ((cur = ksNext (swKS)) != NULL)
> 206:	ksRewind (swKS);
> 208:	while ((cur = ksNext (swKS)) != NULL)
elektraProfileSet:
> 231:	ksRewind (appendedKeys);
> 233:	while ((cur = ksNext (appendedKeys)) != NULL)


>    71	src/plugins/specload/specload.c:26
copyError:
> 69:	keyRewindMeta (src);
> 73:	while ((metaKey = keyNextMeta (src)) != NULL)
elektraSpecloadSet:
> 282:	elektraCursor cursor = ksGetCursor (returned);
> 283:	ksRewind (returned);
> 286:	while ((new = ksNext (returned)) != NULL)
> 300:			ksSetCursor (returned, cursor);
> 315:	while ((old = ksNext (oldData)) != NULL)
> 319:			ksSetCursor (returned, cursor);
> 327:	ksSetCursor (returned, cursor);
readConfig:
> 446:	ksRewind (args);
> 448:	while ((cur = ksNext (args)) != NULL)
keyCompareMeta:
> 686:	keyRewindMeta (key1);
> 687:	keyRewindMeta (key2);
> 688:	while ((meta1 = keyNextMeta (key1)) != 0)
> 690:		const Key * meta2 = keyNextMeta (key2);
> 700:	if (keyNextMeta (key2))
calculateMetaDiff:
> 730:	keyRewindMeta (oldKey);
> 731:	keyRewindMeta (newKey);
> 733:	const Key * oldMeta = keyNextMeta (oldKey);
> 734:	const Key * newMeta = keyNextMeta (newKey);
> 746:			oldMeta = keyNextMeta (oldKey);
> 752:			newMeta = keyNextMeta (newKey);
> 759:			oldMeta = keyNextMeta (oldKey);
> 760:			newMeta = keyNextMeta (newKey);
> 765:	while ((oldMeta = keyNextMeta (oldKey)) != NULL)
> 771:	while ((newMeta = keyNextMeta (newKey)) != NULL)


>    72	src/plugins/yajl/testmod_yajl.c:18
> 48:	ksRewind(ks); // shouldn't that be default?
> 64:	ksRewind(ks); // shouldn't that be default?
> 91:	ksRewind(ks); // shouldn't that be default?
> 110:	ksRewind(ks);
> 503:	ksRewind (ks);
> 506:	succeed_if_equal (keyName (ksCurrent (ks)), "user:/tests/yajl/nullkey");
> 509:	succeed_if_equal (keyName (ksCurrent (ks)), "user:/tests/yajl/second_nullkey");
> 512:	succeed_if (ksCurrent (ks) == 0, "not at end of keyset");
> 516:	ksRewind (ks);
> 519:	succeed_if_equal (keyName (ksCurrent (ks)), "user:/tests/yajl/boolean_key");
> 522:	succeed_if_equal (keyName (ksCurrent (ks)), "user:/tests/yajl/second_boolean_key");
> 525:	succeed_if (ksCurrent (ks) == 0, "not at end of keyset");
> 529:	ksRewind (ks);
> 532:	succeed_if_equal (keyName (ksCurrent (ks)), "user:/tests/yajl/fancy/path/below/v/y/z");
> 535:	succeed_if_equal (keyName (ksCurrent (ks)), "user:/tests/yajl/fancy/path/below/x/y/z");
> 538:	succeed_if (ksCurrent (ks) == 0, "not at end of keyset");
> 542:	ksRewind (ks);
> 545:	succeed_if_equal (keyName (ksCurrent (ks)), "user:/tests/yajl/map/nested_map/second_string_key");



>    73	src/plugins/yajl/yajl_gen.c:13
> 190:		if (!strcmp (keyName (ksTail (returned)), keyName (parentKey)))
> 203:		if (!strcmp (keyName (ksTail (returned)), keyName (toCheck)))
> 205:			ELEKTRA_LOG_DEBUG ("GEN empty array (got %s)", keyName (ksTail (returned)));
> 212:		if (!strcmp (keyName (ksTail (returned)), keyName (toCheck)))
> 214:			ELEKTRA_LOG_DEBUG ("GEN empty map (got %s)", keyName (ksTail (returned)));
> 252:	ksRewind (ks);
> 254:	while ((curr = ksNext (ks)) != 0)
> 260:			elektraCursor cursor = ksGetCursor (ks);
> 269:			ksSetCursor (ks, cursor);
> 286:	if (ksGetSize (returned) == 1 && !strcmp (keyName (parentKey), keyName (ksHead (returned))) &&
> 287:	   keyGetValueSize (ksHead (returned)) > 1)
> 289:		elektraGenValue (g, parentKey, ksHead (returned));
> 302:	ksRewind (returned);


>    74	src/plugins/yajl/yajl_parse.c:23
> 24:	elektraCursor cursor = ksGetCursor (ks);
> 30:	ksSetCursor (ks, cursor);
> 34: @retval 0 if ksCurrent does not hold an array entry
> 41:	Key * current = ksCurrent (ks);
> 77:	Key * current = ksCurrent (ks);
> 91:	Key * current = ksCurrent (ks);
> 113:	Key * current = ksCurrent (ks);
> 135:	Key * current = ksCurrent (ks);
> 155:	Key * currentKey = keyNew (keyName (ksCurrent (ks)), KEY_END);
> 188:	Key * currentKey = ksCurrent (ks);
> 203:	Key * currentKey = ksCurrent (ks);
> 242:	Key * currentKey = ksCurrent (ks);
> 260:	ksRewind (returned);
> 261:	Key * cur = ksNext (returned);
> 264:		elektraCursor cursor = ksGetCursor (returned);
> 266:		if (ksNext (returned) == NULL) break;
> 268:		Key * peekDup = keyDup (ksCurrent (returned), KEY_CP_ALL);
> 273:			const char * baseName = keyBaseName (ksCurrent (returned));
> 279:				ksSetCursor (returned, cursor);
> 289:		cur = ksCurrent (returned);
> 315:			ksRewind (returned);
> 317:			while ((cur = ksNext (returned)) != 0)
> 323:			ksRewind (returned);


>    75	src/plugins/yajl/iterator.c:8
> 75: * ksCurrent() will point at the same key as the key which is returned.
> 93:	const Key * previous = ksNext (ks);
> 97:		ksRewind (ks);
> 103:	const Key * current = previous; // current is same as ksCurrent()
> 106:		pos = ksGetCursor (ks); // remember candidate
> 108:		current = ksNext (ks);	// look forward to next key
> 113:	ksSetCursor (ks, pos);
> 114:	return ksCurrent (ks);

+ 2nd argument for giving start position (previous ksCurrent() was used)
+ src/plugins/yajl/iterator.h
+ 25: Key * elektraNextNotBelow (KeySet * ks, elektraCursor pos);
--> adapt all usages of the function elektraNextNotBelow


>     76	src/plugins/mathcheck/testmod_mathcheck.c:3
> 23:		ksRewind (ks);
> 34:		ksRewind (ks);
> 61:	ksRewind (ks);


>    77	src/plugins/mathcheck/mathcheck.c:2
> 319:				ksRewind (ks);
> 381:	while ((cur = ksNext (returned)) != NULL)


>     78	src/plugins/fstab/fstab.c:3
> 198:	ksRewind (ks);
> 199:	if ((key = ksNext (ks)) != 0)
> 215:	while ((key = ksNext (ks)) != 0)


>    79	src/plugins/mini/mini.c:2
> 288:	ksRewind (keySet);
> 289:	for (Key * key; (key = ksNext (keySet)) != 0 && status >= 0;)

	
>     80	src/plugins/tracer/tracer.c:5
> 28:			while ((k = ksNext (config)) != 0)
> 40:		while ((k = ksNext (config)) != 0)
> 94:	while ((k = ksNext (returned)) != 0)
> 110:	while ((k = ksNext (returned)) != 0)
> 126:	while ((k = ksNext (returned)) != 0)


>    81	src/plugins/mmapstorage/testmod_mmapstorage.c:6
> 678:	ksRewind (returned);
> 679:	while ((current = ksNext (returned)) != 0)
> 690:	ksRewind (returned);
> 691:	while ((current = ksNext (returned)) != 0)
> 713:	ksRewind (ks);
> 714:	while ((current = ksNext (ks)) != 0)


>    82	src/plugins/mmapstorage/mmapstorage.c:12
> 634:	ksRewind (returned);
> 639:	while ((cur = ksNext (returned)) != 0)
> 648:			ksRewind (cur->meta);
> 649:			while ((curMeta = ksNext (cur->meta)) != 0)
> 668:		ksRewind (global);
> 669:		while ((globalKey = ksNext (global)) != 0)
> 678:				ksRewind (globalKey->meta);
> 679:				while ((curMeta = ksNext (globalKey->meta)) != 0)
> 808:	keyRewindMeta (key);
> 812:	while ((metaKey = keyNextMeta (key)) != 0)
> 856:	ksRewind (keySet);
> 857:	while ((cur = ksNext (keySet)) != 0)


>    83	src/plugins/unit/unit.c:3
> 150:	while ((cur = ksNext (returned)) != NULL)
> 176:	ksRewind (returned);
> 177:	while ((cur = ksNext (returned)) != NULL)


    84	src/plugins/line/line.c:4
>  51:		read = keyDup (ksTail (returned), KEY_CP_ALL);
>  102:		ELEKTRA_SET_VALIDATION_SYNTACTIC_ERRORF (parentKey, "Could not increment array from %s", keyName (ksTail (returned)));
> 134:		ksRewind (returned);
> 137:	while ((cur = ksNext (returned)) != 0)


>     85	src/plugins/macaddr/testmod_macaddr.c:2
> 32:	ksRewind (testKs);
> 44:	ksRewind (ks);


>     86	src/plugins/macaddr/macaddr.c:4
> 147:	ksRewind (returned);
> 149:	while ((cur = ksNext (returned)) != NULL)
> 175:	ksRewind (returned);
> 177:	while ((cur = ksNext (returned)) != NULL)


>    87	src/plugins/rgbcolor/rgbcolor.c:4
> 369:	ksRewind (returned);
> 370:	while ((cur = ksNext (returned)) != NULL)
> 386:	ksRewind (returned);
> 387:	while ((cur = ksNext (returned)) != NULL)


>    88	src/plugins/augeas/testmod_augeas.c:6
> 142:	elektraKsPopAtCursor (ks, ksGetCursor (ks));
> 147:	elektraKsPopAtCursor (ks, ksGetCursor (ks));
> 152:	elektraKsPopAtCursor (ks, ksGetCursor (ks));
> 157:	elektraKsPopAtCursor (ks, ksGetCursor (ks));
> 241:	ksRewind (ks);
> 242:	while ((key = ksNext (ks)) != 0)


>    89	src/plugins/xmltool/stream.c:9
> 356:	ksRewind (cks);
> 386:			ksRewind (cks);
> 387:			while ((key = ksNext (cks)) != 0)
> 393:			ksRewind (cks);
> 394:			while ((key = ksNext (cks)) != 0)
> 401:		ksRewind (cks);
> 402:		while ((key = ksNext (cks)) != 0)
> 526:	ksRewind (cks);
> 532:	while ((key = ksNext (cks)) != NULL)


>     90	src/plugins/xmltool/testmod_xmltool.c:4
> 66:	ksRewind (ks);
> 67:	while ((cur = ksNext (ks)))
> 153:	ksRewind (ks);
> 154:	while ((cur = ksNext (ks)))


>    91	src/plugins/rename/rename.c:5
> 272:	ksRewind (iterateKs);
> 282:	while ((key = ksNext (iterateKs)) != 0)
> 355:	ksRewind (iterateKs);
> 359:	while ((key = ksNext (iterateKs)) != 0)
403:	ksRewind (returned);


>     92	src/plugins/rename/testmod_rename.c:2
> 74:	ksRewind (expected);
> 75:	while ((current = ksNext (expected)))


>     93	src/plugins/doc/doc.c:4
> 167:	ksRewind (returned);
> 168:	while ((k = ksNext (returned)) != 0)
> 255:	ksRewind (returned);
> 256:	while ((k = ksNext (returned)) != 0)


>     94	src/plugins/doc/doc.h:2
> 525: *   You also have to make sure that ksGetCursor()
> 563: * ksGetCursor() needs to point to the position where the error appeared. The error


>     95	src/plugins/list/addPluginTest.c:3
> 15:	ksRewind (exports);
> 49:	ksRewind (exports);
> 86:	ksRewind (modules);


>    96	src/plugins/list/list.c:27
listParseConfiguration:
> 95:	ksRewind (cutKS);
> 102:	while ((cur = ksNext (cutKS)) != NULL)
elektraListDeferredCall:
> 179:	ksRewind (placements->plugins);
> 181:	while ((current = ksNext (placements->plugins)) != NULL)
elektraListOpen:
> 217:	ksRewind (config);
elektraListClose:
> 279:	ksRewind (placements->plugins);
> 280:	while ((cur = ksNext (placements->plugins)) != NULL)
runPlugins:
> 344:				ksRewind (pluginConfigWithConfigPrefix);
elektraListGet:
> 411:	ksRewind (pluginKS);
> 413:			     elektraPluginGetGlobalKeySet (handle), parentKey, GET, ksNext, placements->deferredCalls);
elektraListSet:
> 429:	ksRewind (pluginKS);
elektraListError:
> 450:	ksRewind (pluginKS);
elektraListAddPlugin:
> 468:	ksRewind (pluginConfig);
> 469:	ksNext (pluginConfig);
> 470:	Key * lookup = ksNext (pluginConfig);
> 484:	ksRewind (conf);
findPluginInConfig:
> 640:	ksRewind (array);
> 642:	while ((cur = ksNext (array)) != NULL)
resetPlugins:
> 672:	ksRewind (placements->plugins);
> 673:	while ((cur = ksNext (placements->plugins)) != NULL)
elektraListFindPlugin:
> 896:		while ((current = ksNext (placements->getKS[i])) != NULL)
> 910:		while ((current = ksNext (placements->setKS[i])) != NULL)
> 924:		while ((current = ksNext (placements->errKS[i])) != NULL)
elektraListEditPlugin:
> 945:	ksRewind (pluginConfig);
> 946:	ksNext (pluginConfig);
> 947:	Key * lookup = ksNext (pluginConfig);
> 961:	ksRewind (conf);


    97	src/plugins/error/error.c:3
> 26:	ksRewind(conf);
> 27:	while (ksNext(conf)) fprintf(f, "%s\n", keyName(ksCurrent(conf)));
> 79:	while ((cur = ksNext (returned)) != 0)


    98	src/plugins/passwd/passwd.c:4
> 228:	ksRewind (ks);
> 229:	Key * parent = ksNext (ks);
> 304:	ksRewind (returned);
> 305:	while ((cur = ksNext (returned)) != NUL


>    99	src/plugins/passwd/testmod_passwd.c:1
> 59:	ksRewind (ks);


>   100	src/plugins/dbus/dbus.c:5
> 79:	ksRewind (ks);
> 81:	while ((k = ksNext (ks)) != 0)
> 95:	ksRewind (oldKeys);
> 96:	ksRewind (returned);
> 103:	while ((k = ksNext (oldKeys)) != 0)


>   101	src/plugins/mozprefs/mozprefs.c:1
> 247:	while ((cur = ksNext (returned)) != NULL)


>    102	src/plugins/hexnumber/hexnumber.c:4
> 328:	ksRewind (returned);
> 339:	while ((cur = ksNext (returned)) != NULL)
> 399:	ksRewind (returned);
> 402:	while ((cur = ksNext (returned)) != NULL)


>   103	src/plugins/toml/prepare.c:20
prepareKeySet:
> 38:	elektraCursor cursor = ksGetCursor (keys);
> 43:		ksSetCursor (keys, cursor);
> 47:	ksSetCursor (keys, cursor);
completeKeySetComments:
> 53:	ksRewind (keys);
> 55:	while ((key = ksNext (keys)) != NULL)
completeKeyComments:
> 63:	keyRewindMeta (key);
orderUnorderedKeys:
> 100:	ksRewind (keys);
addMissingArrayKeys:
> 115:	ksRewind (keys);
> 117:	while ((key = ksNext (keys)) != NULL)
pruneInvalidArrayKeys:
> 168:	ksRewind (keys);
> 170:	Key * key = ksNext (keys);
> 177:			while ((sub = ksNext (keys)) != NULL && keyIsBelow (key, sub) == 1)
> 187:			key = ksCurrent (keys);
> 191:			key = ksNext (keys);
> 194:	ksRewind (pruneSet);
> 195:	while ((key = ksNext (pruneSet)) != NULL)
assignContinuousOrder:
> 237:	ksRewind (ksUnordered);
> 239:	while ((key = ksNext (ksUnordered)) != NULL)
getMaxOrder:
> 247:	ksRewind (ks);
> 250:	while ((key = ksNext (ks)) != NULL)


>   104	src/plugins/toml/node.c:9
buildTree:
> 47:			while ((key = ksCurrent (keys)) != NULL && keyIsBelow (root, key) == 1)
> 49:				ksNext (keys);
buildTreeTableArray:
> 81:		if (keyCmp (ksCurrent (keys), elementName) == 0)
> 84:			elementName = ksCurrent (keys);
> 85:			ksNext (keys);
buildTreeArray:
> 111:				ksNext (keys); // we need to go to the first sub key of the element, since buildTree
> 112:			}		      // loops while ksCurrent is below root key (and root != below root)
> 124:	while ((key = ksCurrent (keys)) != NULL && keyIsBelow (root, key) == 1)
> 126:		ksNext (keys);


>   105	src/plugins/toml/driver.c:1
> 72:	ksRewind (keys);

   
>   106	src/plugins/toml/write.c:8
tomlWrite:
> 93:	elektraCursor cursor = ksGetCursor (keys);
> 96:	ksRewind (keys);
> 97:	ksNext (keys);
> 98:	if (keyCmp (ksCurrent (keys), parent) == 0)
> 100:		ksNext (keys);
> 125:	ksSetCursor (keys, cursor);
collectComments:
> 776:	keyRewindMeta (key);
> 781:	while ((meta = keyNextMeta (key)) != NULL)

   
>   107	src/plugins/toml/utility.c:11
keySetDiff:
> 279:	ksRewind (part);
> 281:	while ((key = ksNext (part)) != NULL)
keysByPredicate:
> 294:	ksRewind (ks);
> 296:	while ((key = ksNext (ks)) != NULL)
collectSubKeys
> 309:	ksRewind (ks);
> 311:	while ((key = ksNext (ks)) != NULL)
isLeaf:
> 330:	elektraCursor cursor = ksGetCursor (ks);
> 331:	ksRewind (ks);
> 333:	while ((key = ksNext (ks)) != NULL)
> 337:			ksSetCursor (ks, cursor);
> 341:	ksSetCursor (ks, cursor);


>   108	src/plugins/crypto/helper.c:4
> 263:	ksRewind (conf);
> 264:	while ((k = ksNext (conf)) != 0)
> 300:	ksRewind (conf);
> 301:	while ((k = ksNext (conf)) != 0)


>   109	src/plugins/crypto/crypto.c:4
> 205:	ksRewind (data);
> 206:	while ((k = ksNext (data)) != 0)
> 257:	ksRewind (data);
> 258:	while ((k = ksNext (data)) != 0)


>   110	src/plugins/crypto/gpg.c:2
> 457:	ksRewind (conf);
> 458:	while ((k = ksNext (conf)) != 0)

   
>   111	src/plugins/crypto/testmod_crypto.c:2
> 214:		ksRewind (data);
> 215:		while ((k = ksNext (data)) != 0)
   

>    112	src/plugins/simpleini/simpleini.c:2
> 364:	ksRewind (returned);
> 365:	while ((cur = ksNext (returned)) != 0)


>   113	src/plugins/spec/spec.c:27
handleErrors:
> 352:	elektraCursor cursor = ksGetCursor (ks);
> 354:	ksSetCursor (ks, cursor);
processAllConflicts:
> 367:	ksRewind (ks);
> 368:	while ((cur = ksNext (ks)) != NULL)
validateArraySize:
> 484:	ksRewind (subKeys);
> 485:	while ((cur = ksNext (subKeys)) != NULL)
validateArrayMembers:
> 548:	ksRewind (subKeys);
> 549:	while ((cur = ksNext (subKeys)) != NULL)
instantiateArraySpec:
> 576:	elektraCursor cursor = ksGetCursor (ks);
> 596:			ksRewind (newKeys);
> 597:			while ((k = ksNext (newKeys)) != NULL)
> 655:			ksRewind (newKeys);
> 656:			while ((k = ksNext (newKeys)) != NULL)
> 676:	ksRewind (newKeys);
> 677:	while ((k = ksNext (newKeys)) != NULL)
> 683:	ksSetCursor (ks, cursor);
validateWildcardSubs:
> 740:	while ((cur = ksNext (subKeys)) != NULL)
elektraSpecGet:
> 932:	ksRewind (returned);
> 933:	while ((cur = ksNext (returned)) != NULL)
> 964:	ksRewind (specKS);
> 965:	while ((specKey = ksNext (specKS)) != NULL)
elektraSpecSet:
> 1003:	ksRewind (returned);
> 1004:	while ((cur = ksNext (returned)) != NULL)
> 1035:	ksRewind (specKS);
> 1036:	while ((specKey = ksNext (specKS)) != NULL)
> 1057:	ksRewind (ks);
> 1058:	while ((cur = ksNext (ks)) != NULL)


>   114	src/plugins/lua/testmod_lua.c:1
> 30:	succeed_if (ksGetSize (ks) == 1 && !strcmp (keyName (ksHead (ks)), "user:/from_lua"), "key in keyset has wrong name");


>   115	src/plugins/email/email.c:2
> 70:	ksRewind (returned);
> 71:	while ((cur = ksNext (returned)) != NULL)


>   116	src/plugins/logchange/logchange.c:5
> 22:	ksRewind (ks);
> 24:	while ((k = ksNext (ks)) != 0)
> 68:	ksRewind (oldKeys);
> 69:	ksRewind (returned);
> 76:	while ((k = ksNext (oldKeys)) != 0)


>   117	src/plugins/network/network.c:2
> 169:	ksRewind (returned);
> 170:	while ((cur = ksNext (returned)) != 0)


>   118	src/plugins/iterate/iterate.c:1
> 33:	while ((k = ksNext (returned)))


>   119	src/plugins/iterate/testmod_iterate.c:2
> 39:	ksRewind (ks);
> 42:	ksRewind (ks);


>   120	src/plugins/syslog/syslog.c:2
> 72:	ksRewind (returned);
> 73:	while ((k = ksNext (returned)))


>   121	src/plugins/ipaddr/ipaddr.c:2
> 140:	ksRewind (returned);
> 141:	while ((cur = ksNext (returned)) != NULL)

   
>    122	src/plugins/fcrypt/fcrypt.c:6
> 210:	ksRewind (config);
> 211:	while ((k = ksNext (config)) != 0)
> 380:		ksRewind (pluginConfig);
> 381:		while ((k = ksNext (pluginConfig)) != 0)
> 408:		ksRewind (pluginConfig);
> 409:		while ((k = ksNext (pluginConfig)) != 0)


>   123	src/plugins/quickdump/quickdump.c:6
> 375:	elektraCursor cursor = ksGetCursor (returned);
> 376:	ksRewind (returned);
> 421:	while ((cur = ksNext (returned)) != NULL)
> 483:		keyRewindMeta (cur);
> 485:		while ((meta = keyNextMeta (cur)) != NULL)
> 553:	ksSetCursor (returned, cursor);


>   124	src/plugins/hexcode/hexcode.c:5
> 133:	ksRewind (returned);
> 134:	while ((cur = ksNext (returned)) != 0)
> 251:	ksRewind (returned);
> 252:	while ((cur = ksNext (returned)) != 0)
> 299:		while ((cur = ksNext (config)) != 0)


>   125	src/plugins/conditionals/testmod_conditionals.c:34
> 28:	ksRewind (ks);
> 45:	ksRewind (ks);
> 62:	ksRewind (ks);
> 79:	ksRewind (ks);
> 97:	ksRewind (ks);
> 116:	ksRewind (ks);
> 135:	ksRewind (ks);
> 153:	ksRewind (ks);
> 172:	ksRewind (ks);
> 189:	ksRewind (ks);
> 206:	ksRewind (ks);
> 223:	ksRewind (ks);
> 242:	ksRewind (ks);
> 261:	ksRewind (ks);
> 283:	ksRewind (ks);
> 303:	ksRewind (ks);
> 323:	ksRewind (ks);
> 342:	ksRewind (ks);
> 365:	ksRewind (ks);
> 386:	ksRewind (ks);
> 405:	ksRewind (ks);
> 423:	ksRewind (ks);
> 441:	ksRewind (ks);
> 459:	ksRewind (ks);
> 481:	ksRewind (ks);
> 500:	ksRewind (ks);
> 518:	ksRewind (ks);
> 536:	ksRewind (ks);
> 554:	ksRewind (ks);
> 572:	ksRewind (ks);
> 590:	ksRewind (ks);
> 607:	ksRewind (ks);
> 627:	ksRewind (ks);
> 647:	ksRewind (ks);


>   126	src/plugins/conditionals/conditionals.c:7
> 850:	while ((c = ksNext (condKS)) != NULL)
> 906:	ksRewind (returned);
> 908:	while ((cur = ksNext (returned)) != NULL)
> 956:				while ((a = ksNext (assignKS)) != NULL)
> 990:	ksRewind (returned);
> 992:	while ((cur = ksNext (returned)) != NULL)
> 1040:				while ((a = ksNext (assignKS)) != NULL)


>   127	src/plugins/reference/reference.c:12
checkSingleReference:
> 122:	ksRewind (refArray);
> 124:	while ((arrayElement = ksNext (refArray)) != NULL)
> 145:			ksRewind (restrictions);
> 148:			while ((curRestriction = ksNext (restrictions)) != NULL)
checkRecursiveReference:
> 321:			ksRewind (refArray);
> 323:			while ((arrayElement = ksNext (refArray)) != NULL)
> 347:					ksRewind (restrictions);
> 350:					while ((curRestriction = ksNext (restrictions)) != NULL)
elektraReferenceSet:
> 419:	ksRewind (returned);
> 422:	while ((cur = ksNext (returned)) != NULL)
> 432:		elektraCursor cursor = ksGetCursor (returned);
> 442:		ksSetCursor (returned, cursor);


>   128	src/plugins/iconv/iconv.c:4
> 152:	ksRewind (returned);
> 170:	while ((cur = ksNext (returned)) != 0)
> 220:	ksRewind (returned);
> 222:	while ((cur = ksNext (returned)) != 0)


>   129	src/plugins/blockresolver/blockresolver.c:1
> 111:		ksRewind (config);








# Libs
   130	src/libs/opts/opts.c:42
148:	elektraCursor initial = ksGetCursor (ks);
158:		ksSetCursor (ks, initial);
186:				ksSetCursor (ks, initial);
215:				ksSetCursor (ks, initial);
229:				ksSetCursor (ks, initial);
246:				ksSetCursor (ks, initial);
276:			ksSetCursor (ks, initial);
289:		ksSetCursor (ks, initial);
691:	ksRewind (opts);
692:	ksNext (opts); // skip count
697:	while ((metaKey = ksNext (opts)) != NULL)
1027:	ksRewind (envVars);
1028:	ksNext (envVars); // skip count
1030:	while ((k = ksNext (envVars)) != NULL)
1233:	ksRewind (optMetas);
1234:	ksNext (optMetas); // skip count
1237:	while ((optMeta = ksNext (optMetas)) != NULL)
1290:	ksRewind (envMetas);
1291:	ksNext (envMetas); // skip count
1293:	while ((envMeta = ksNext (envMetas)) != NULL)
1362:		ksRewind (args);
1497:		ksRewind (values);
1499:		ksNext (values); // skip count
1500:		while ((cur = ksNext (values)) != NULL)
1880:		ksRewind (spec->keys);
1881:		while ((keyWithOpt = ksNext (spec->keys)) != NULL)
2107:	elektraCursor cursor = ksGetCursor (keysWithOpts);
2112:	ksRewind (keysWithOpts);
2113:	while ((cur = ksNext (keysWithOpts)) != NULL)
2137:	ksSetCursor (keysWithOpts, cursor);
2148:	elektraCursor cursor = ksGetCursor (keysWithOpts);
2153:	ksRewind (keysWithOpts);
2154:	while ((cur = ksNext (keysWithOpts)) != NULL)
2188:	ksSetCursor (keysWithOpts, cursor);
2199:	elektraCursor cursor = ksGetCursor (keysWithOpts);
2204:	ksRewind (keysWithOpts);
2205:	while ((cur = ksNext (keysWithOpts)) != NULL)
2230:	ksSetCursor (keysWithOpts, cursor);
2241:	elektraCursor cursor = ksGetCursor (keysWithOpts);
2246:	ksRewind (keysWithOpts);
2247:	while ((cur = ksNext (keysWithOpts)) != NULL)
2267:	ksSetCursor (keysWithOpts, cursor);


   131	src/libs/meta/meta.c:4
359:	ksRewind (result);
578:	ksRewind (ks);
619:			tmpDep = ksHead (deps);
634:			while ((tmpDep = ksNext (deps)) != NULL)


   132	src/libs/globbing/globbing.c:4
211:	elektraCursor cursor = ksGetCursor (input);
212:	ksRewind (input);
213:	while ((current = ksNext (input)) != 0)
222:	ksSetCursor (input, cursor);


   133	src/libs/ease/functional.c:8
51:	elektraCursor cursor = ksGetCursor (input);
52:	ksRewind (input);
53:	while ((current = ksNext (input)) != 0)
64:	ksSetCursor (input, cursor);
95:	elektraCursor cursor = ksGetCursor (ks);
96:	ksRewind (ks);
100:	while ((key = ksNext (ks)) != 0)
105:	ksSetCursor (ks, cursor);


   134	src/libs/highlevel/elektra.c:3
587:			Key * problemKey = ksCurrent (elektra->config);
601:	ksRewind (defaults);
602:	for (Key * key = ksNext (defaults); key != NULL; key = ksNext (defaults))


   135	src/libs/pluginprocess/pluginprocess.c:2
354:		keyRewindMeta (key);
356:		while ((currentMeta = keyNextMeta (key)) != NULL)


   136	src/libs/elektra/symbols.map:10
49:	keyCurrentMeta;
73:	keyNextMeta;
74:	keyRewindMeta;
93:	ksCurrent;
99:	ksGetCursor;
101:	ksHead;
106:	ksNext;
109:	ksRewind;
110:	ksSetCursor;
111:	ksTail;


   137	src/libs/elektra/mount.c:6
58:	ksRewind (config);
62:	while ((cur = ksNext (config)) != 0)
377:		root = ksHead (keys);
384:	while ((cur = ksNext (global)) != NULL)
419:				while ((curSubPosition = ksNext (subPositions)) != NULL)
484:	while ((cur = ksNext (modules)) != 0)


   138	src/libs/elektra/plugin.c:5
152:	ksRewind (config);
154:	root = ksNext (config);
156:	while ((cur = ksNext (config)) != 0)
183:				ksRewind (pluginConfig);
357:	ksRewind (exports);


   139	src/libs/elektra/keymeta.c:25
131: * keyCurrentMeta() will always return NULL after rewinding, so
132: * you need to call keyNextMeta() first.
138:keyRewindMeta (key);
139:while ((meta = keyNextMeta (key))!=0)
149: *         (keyNextMeta() will always return 0 in that case)
155: * @see keyNextMeta(), keyCurrentMeta() for iterating after rewinding
156: * @see ksRewind() KeySet's equivalent function for rewinding
158:int keyRewindMeta (Key * key)
163:	return ksRewind (key->meta);
169: * Keys have an internal cursor that can be reset with keyRewindMeta(). Every
170: * time keyNextMeta() is called the cursor is incremented and the new current
174: * On subsequent calls of keyNextMeta() it will still return the NULL pointer.
193: * @see ksNext() for pedant in iterator interface of KeySet
194: * @see keyRewindMeta() for rewinding the internal iterator
195: * @see keyCurrentMeta() for getting the current metadata Key
197:const Key * keyNextMeta (Key * key)
203:	ret = ksNext (key->meta);
212: * ksRewind().
225: * @see keyNextMeta() for getting the next value
226: * @see keyRewindMeta() for rewinding the internal iterator
227: * @see ksCurrent() KeySets's equivalent function for getting the current Key
229:const Key * keyCurrentMeta (const Key * key)
235:	ret = ksCurrent (key->meta);
277:	ksRewind(ks);
278:	while ((current = ksNext(ks)) != 0)


   140	src/libs/elektra/kdb.c:30
136:	keyRewindMeta (key);
137:	while ((iter_key = keyNextMeta (key)) != 0)
162:	ksRewind (config);
164:	root = ksNext (config);
498:	ksRewind (keys);
499:	for (key = ksNext (keys); key; key = ksNext (keys))
669:			ksRewind (split->keysets[i]);
743:		ksRewind (split->keysets[i]);
768:	ksRewind (ks);
774:	ksRewind (specCut);
776:	while ((cur = ksNext (specCut)) != NULL)
788:	ksRewind (cutKS);
831:		ksRewind (split->keysets[i]);
852:				ksRewind (ks);
860:				ksRewind (ks);
868:				ksRewind (ks);
918:	keyRewindMeta (src);
922:	while ((metaKey = keyNextMeta (src)) != NULL)
1091:	ksRewind (*cache);
1413:			ELEKTRA_ADD_PLUGIN_MISBEHAVIOR_WARNINGF (parentKey, "Wrong keys in postprocessing: %s", keyName (ksCurrent (ks)));
1461:			ELEKTRA_ADD_PLUGIN_MISBEHAVIOR_WARNINGF (parentKey, "Wrong keys in postprocessing: %s", keyName (ksCurrent (ks)));
1509:	ksRewind (ks);
1559:			ksRewind (split->keysets[i]);
1596:					ksRewind (split->keysets[i]);
1604:					ksRewind (split->keysets[i]);
1617:				*errorKey = ksCurrent (split->keysets[i]);
1655:				ksRewind (split->keysets[i]);
1693:			ksRewind (split->keysets[i]);
1781: * @see ksCurrent() contains the error Key
1870:						keyName (ksCurrent (ks)));


   141	src/libs/elektra/proposal.c:7
20: * The internal cursor will be rewinded using ksRewind(). You can use
21: * ksGetCursor() and ksSetCursor() jump back to the previous position.
22: * e.g. to pop at current position within ksNext() loop:
24: * cursor_t c = ksGetCursor(ks);
26: * ksSetCursor(ks, c);
27: * ksPrev(ks); // to have correct key after next ksNext()
68:	ksRewind (ks);


   142	src/libs/elektra/split.c:9
380:	ksRewind (ks);
381:	while ((curKey = ksNext (ks)) != 0)
448:	ksRewind (ks);
449:	while ((curKey = ksNext (ks)) != 0)
472:	const Key * k = ksCurrent (ks);
494:	elektraCursor c = ksGetCursor (ks);
496:	ksSetCursor (ks, c - 1); // next ksNext() will point correctly again
514:	ksRewind (split->keysets[i]);
515:	while ((cur = ksNext (split->keysets[i])) != 0)


   143	src/libs/elektra/keyset.c:86
111: * also the pointer to the current metadata keyNextMeta()
134: * - With ksRewind() and ksNext() you can iterate through the keyset.
140: * KeySets have an @link ksCurrent() internal cursor @endlink.
286:	ksRewind (keyset); // ksAppendKey changed the internal cursor
389: * and ksCurrent() will be set properly in @p dest.
428:	ksSetCursor (dest, ksGetCursor (source));
939:		ksSetCursor (ks, result);
976:			ksSetCursor (ks, ks->size - 1);
987:			ksSetCursor (ks, insertpos);
1314:			ksRewind (ks);
1328:			ksRewind (ks);
1521: * @see ksTail() for getting the last Key of a KeySet without removing it
1554: * ksCurrent() will always return NULL afterwards. So
1555: * you want to use ksNext() first.
1558:ksRewind (ks);
1559:while ((key = ksNext (ks))!=0) {}
1568: * @see ksNext() for moving the cursor to the next entry in the KeySet
1569: * @see ksCurrent() for getting the current element in the KeySet
1571:int ksRewind (KeySet * ks)
1584: * KeySets have an internal cursor that can be reset with ksRewind(). Every
1585: * time ksNext() is called, the cursor is incremented and the new current Key
1589: * On subsequent calls of ksNext() it will still return the NULL pointer.
1605: * @see ksRewind() for resetting the internal cursor of the KeySet
1606: * @see ksCurrent() for getting the Key the cursor currently points at
1609:Key * ksNext (KeySet * ks)
1628: * ksRewind().
1639: * @see ksNext() to get the next Key in the KeySet
1640: * @see ksRewind() for resetting the internal cursor of the KeySet
1642:Key * ksCurrent (const KeySet * ks)
1655: * If ksCurrent()==ksHead() you know you are
1664: * @see ksTail() for getting the last Key of the KeySet
1665: * @see ksRewind(), ksCurrent() and ksNext() for iterating over the KeySet
1667:Key * ksHead (const KeySet * ks)
1683: * If ksCurrent()==ksTail() you know you
1684: * are on the last key. ksNext() will return
1693: * @see ksHead() for getting the first Key of a KeySet
1694: * @see ksRewind(), ksCurrent() and ksNext() for iterating over the KeySet
1696:Key * ksTail (const KeySet * ks)
1721:ksRewind (ks);
1722:while ((key = keyNextMeta (ks))!=0)
1725:	jump = ksGetCursor(ks);
1728:	keyNextMeta (ks); // now browse on
1729:	// use ksCurrent(ks) to check the keys
1733:	ksSetCursor(ks, jump);
1745:	elektraCursor state = ksGetCursor(ks);
1750:	ksSetCursor (ks, state);
1761: * ksRewind(). When you set an invalid cursor ksCurrent()
1762: * is 0 and ksNext() == ksHead().
1784: * @retval -1 on an invalid internal cursor or after ksRewind
1787: * @see ksNext() for moving the internal cursor forward
1788: * @see ksSetCursor() for setting the cursor to a specific position
1791:elektraCursor ksGetCursor (const KeySet * ks)
1814: * @see ksGetCursor() for getting the cursor at the current position
1815: * @see ksSetCursor() for setting the cursor to a specific position
1830: * ksCurrent() will then return the Key at the position of the supplied cursor.
1840:cursor = ksGetCursor (ks);
1841:while ((key = keyNextMeta (ks))!=0) {}
1842:ksSetCursor (ks, cursor); // reset state
1843:ksCurrent(ks); // in same position as before
1847: * ksRewind(). When you set an invalid cursor ksCurrent()
1848: * is 0 and ksNext() == ksHead().
1853: * @retval 0 when the KeySet has been ksRewind()ed
1858: * @see ksGetCursor() for getting the cursor at the current position
1859: * @see ksNext() for moving the internal cursor forward
1860: * @see ksCurrent() for getting the Key at the current position
1862:int ksSetCursor (KeySet * ks, elektraCursor cursor)
1868:		ksRewind (ks);
1886:	keyRewindMeta (dest);
1887:	while ((m = keyNextMeta (dest)))
1896:	keyRewindMeta (source);
1897:	while ((m = keyNextMeta (source)))
2172:	cursor = ksGetCursor (ks);
2187:			ksSetCursor (ks, cursor);
2193:		ksSetCursor (ks, cursor);
2301:	cursor = ksGetCursor (ks);
2319:			ksSetCursor (ks, cursor);
2325:		ksSetCursor (ks, cursor);
2489: * (also accessible by ksCurrent()), and a pointer to the Key is returned.
2513: * When ::KDB_O_POP is set the Key which was found will be ksPop()ed. ksCurrent()
2514: * will not be changed, only iff ksCurrent() is the searched Key, then the KeySet
2515: * will be ksRewind()ed.
2521: * iff you use ::KDB_O_POP, so don't use this if you rely on a cursor, see ksGetCursor().
2550: * @see ksCurrent(), ksRewind(), ksNext() for iterating over a KeySet
2614: * @see ksCurrent(), ksRewind(), ksNext() for iterating over a KeySet
2758:	ksRewind (ks);
2808:	ksRewind (ks);


   144	src/libs/elektra/backend.c:10
66: * @pre ksCurrent() is root key
67: * @post ksCurrent() is root key
74:	Key * root = ksCurrent (elektraConfig);
79:	ksLookup (elektraConfig, root, 0); // reset ksCurrent()
176:	ksRewind (elektraConfig);
178:	Key * root = ksNext (elektraConfig);
186:	while ((cur = ksNext (elektraConfig)) != 0)
342:	elektraCursor save = ksGetCursor (modules);
345:	Key * cur = ksCurrent (modules);
372:	ksSetCursor (modules, save);


   145	src/libs/elektra/keyvalue.c:2
127:ksRewind(ks);
128:while (current=ksNext(ks)) {


   146	src/libs/merge/kdbmerge.c:16
245:	ksRewind (input);
246:	while ((key = ksNext (input)) != NULL)
292:	ksRewind (original);
296:	while ((currentKey = ksNext (original)) != NULL)
615:	ksRewind (checkedSet);
616:	ksRewind (firstCompared);
617:	ksRewind (secondCompared);
619:	while ((checkedKey = ksNext (checkedSet)) != NULL)
842:	while ((checkedKey = ksNext (baseSet)) != NULL)
981:	ksRewind (ourCropped);
982:	ksRewind (theirCropped);
983:	ksRewind (baseCropped);
1008:	ksRewind (ourCropped);
1009:	ksRewind (theirCropped);
1010:	ksRewind (baseCropped);
1014:	ksRewind (ourCropped);


# Bindings
   147	src/bindings/jna/libelektra/src/main/java/org/libelektra/Elektra.java:6
   148	src/bindings/jna/libelektra/src/main/java/org/libelektra/Key.java:3
   149	src/bindings/jna/libelektra/src/main/java/org/libelektra/NativePlugin.java:3
   150	src/bindings/jna/libelektra/src/main/java/org/libelektra/KeySet.java:2
   151	src/bindings/cpp/tests/testcpp_meta.cpp:1
   152	src/bindings/cpp/include/keyset.hpp:14
   153	src/bindings/cpp/include/key.hpp:6
   154	src/bindings/intercept/fs/intercept.c:4
   155	src/bindings/intercept/env/tests/test_getenv.cpp:2
   156	src/bindings/intercept/env/src/getenv.cpp:2
   157	src/bindings/glib/gelektra-keyset.c:4
   158	src/bindings/glib/gelektra-key.c:5
   159	src/bindings/rust/elektra-sys/src/lib.rs:5
   160	src/bindings/rust/elektra/src/key.rs:1
   161	src/bindings/rust/elektra/src/readable.rs:1
   162	src/bindings/rust/elektra/src/writeable.rs:1
   163	src/bindings/rust/elektra/src/keyset.rs:6

# Tools


>   164	src/tools/race/race.c:2
> Code was commented out --> removed comment
>48:		ksRewind (ks);
>51:		while ((c = ksNext(ks)))


# Include files
   165	src/include/kdbmacros.h:5
77:		ksRewind (info);
78:		ksRewind (returned);
79:		while ((k = ksNext (returned)))
81:			Key * c = ksNext (info);
101:		if ((k = ksNext (info)) != 0)


   166	src/include/kdb.h.in:10
150:int keyRewindMeta (Key *key);
151:const Key *keyNextMeta (Key *key);
152:const Key *keyCurrentMeta (const Key *key);
241:int ksRewind (KeySet *ks);
242:Key *ksNext (KeySet *ks);
243:Key *ksCurrent (const KeySet *ks);
245:Key *ksHead (const KeySet *ks);
246:Key *ksTail (const KeySet *ks);
248:elektraCursor ksGetCursor (const KeySet *ks);
249:int ksSetCursor (KeySet *ks, elektraCursor cursor);



# Tests
   167	tests/abi/testabi_ks.c:329
86:	succeed_if (ksCurrent (ks_c) == 0, "should be rewinded");
177:	succeed_if (ksHead (0) == 0, "Not NULL on NULL KeySet");
178:	succeed_if (ksTail (0) == 0, "Not NULL on NULL KeySet");
180:	succeed_if (ksHead (ks) == 0, "Not NULL on empty KeySet");
181:	succeed_if (ksTail (ks) == 0, "Not NULL on empty KeySet");
187:	succeed_if (ksHead (ks) == k1, "head wrong");
188:	succeed_if (ksTail (ks) == k1, "tail wrong");
198:	ksRewind (ks);
199:	ksNext (ks);
200:	succeed_if_same_string (keyValue (ksCurrent (ks)), "newvalue");
210:	succeed_if (ksHead (ks) == k2, "head wrong");
211:	succeed_if (ksTail (ks) == k1, "tail wrong");
222:	succeed_if (ksHead (ks1) == k2, "head in dup wrong");
223:	succeed_if (ksTail (ks1) == k1, "tail in dup wrong");
453:	succeed_if (ksNext (0) == 0, "No NULL pointer on NULL pointer keyset");
454:	succeed_if (ksCurrent (0) == 0, "No NULL pointer on NULL pointer keyset");
455:	succeed_if (ksRewind (0) == -1, "No error on NULL pointer");
457:	succeed_if (ksCurrent (ks) == 0, "No NULL pointer on empty keyset");
458:	succeed_if (ksNext (ks) == 0, "No NULL pointer on empty keyset");
459:	succeed_if (ksRewind (ks) == 0, "Cannot rewind empty keyset");
468:	succeed_if (ksRewind (ks) == 0, "Could not rewind keyset");
469:	succeed_if (ksRewind (ks) == 0, "Could not rewind keyset twice");
471:	succeed_if (ksGetCursor (ks) == -1, "Internal cursor after rewinding is set");
473:	succeed_if (ksNext (ks) != 0, "Could not get first key");
474:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/1");
476:	succeed_if (ksNext (ks) != 0, "Could not get second key");
477:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/2");
479:	succeed_if (ksNext (ks) != 0, "Could not get third key");
480:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/3");
482:	succeed_if (ksNext (ks) != 0, "Could not get fourth key");
483:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/4");
485:	succeed_if (ksNext (ks) != 0, "Could not get fifth key");
486:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/5");
488:	succeed_if (ksNext (ks) == 0, "Could not iterate over last");
489:	succeed_if (ksCurrent (ks) == 0, "This is not the beyond last key");
491:	succeed_if (ksNext (ks) == 0, "Could not iterate over last (again)");
492:	succeed_if (ksCurrent (ks) == 0, "This is not the beyond last key (again)");
549:	succeed_if (ksCurrent (ks) == cur, "cursor not set after append key");
551:	succeed_if (ksCurrent (ks) == cur, "cursor not set after append key");
553:	succeed_if (ksCurrent (ks) == cur, "cursor not set after append key");
554:	cursor = ksGetCursor (ks);
557:	succeed_if (ksCurrent (ks) == cur, "cursor not set after append key");
559:	succeed_if (ksCurrent (ks) == cur, "cursor not set after append key");
563:	ksSetCursor (ks, cursor);
564:	succeed_if (cursor == ksGetCursor (ks), "cursor not set to 3");
566:	ksSetCursor (ks, cursor);
567:	succeed_if (cursor == ksGetCursor (ks), "cursor not set to 3 (again)");
569:	cursor = ksGetCursor (ks);
571:	succeed_if (cursor == ksGetCursor (ks), "cursor should stay the same");
575:	ksRewind (ks);
578:		ksNext (ks);
581:			cursor = ksGetCursor (ks);
585:	ksSetCursor (ks, cursor);
586:	ksCurrent (ks);
593:	ksRewind (ks);
596:		ksNext (ks);
599:			cursor = ksGetCursor (ks);
604:	ksSetCursor (ks, cursor);
605:	key = ksCurrent (ks);
613:	ksRewind (ks);
616:		ksNext (ks);
617:		cursor = ksGetCursor (ks);
650:	ksRewind (ks);
658:		ksNext (ks);
659:		cursor = ksGetCursor (ks);
668:	ksRewind (ks);
669:	ksNext (ks);
670:	cursor = ksGetCursor (ks);
671:	ksNext (ks);
672:	ksNext (ks);
677:	ksRewind (ks);
678:	ksNext (ks);
679:	cursor = ksGetCursor (ks);
680:	ksNext (ks);
683:	current = ksNext (ks);
707:	ksRewind (ks);
708:	key = ksNext (ks);
711:	key = ksNext (ks);
714:	key = ksNext (ks);
734:	ksRewind (ks);
735:	for (i = 0; (key = ksNext (ks)) != 0; i++)
789:	ksRewind (ks);
790:	ksNext (ks);
799:	ksRewind (ks);
800:	ksNext (ks);
816:	ksRewind (ks);
817:	for (i = 0; (key = ksNext (ks)) != 0; i++)
866:	ksRewind (ks);
868:	for (i = 0; (key = ksNext (ks)) != 0; i++)
925:	ksRewind (ks);
927:	for (i = 0; (key = ksNext (ks)) != 0; i++)
979:		ksRewind (ks);
1193:	succeed_if (ksCurrent (ks) == found, "current not set correctly");
1196:	succeed_if (ksCurrent (ks) == found, "current not set correctly");
1201:	succeed_if (ksCurrent (ks) == found, "current update after append");
1237:	succeed_if (ksCurrent (ks) == found, "current not set correctly");
1243:	succeed_if (ksCurrent (ks) == found, "current not set correctly");
1249:	succeed_if (ksCurrent (ks) == found, "current not set correctly");
1255:	succeed_if (ksCurrent (ks) == found, "current not set correctly");
1261:	succeed_if (ksCurrent (ks) == found, "current not set correctly");
1288:	succeed_if (ksCurrent (ks) == found, "current not set correctly");
1294:	succeed_if (ksCurrent (ks) == found, "current not set correctly");
1306:	succeed_if (ksCurrent (ks) == found, "current not set correctly");
1312:	succeed_if (ksCurrent (ks) == found, "current not set correctly");
1324:	succeed_if (ksCurrent (ks) == 0, "current not set correctly");
1428:	ksRewind (ks);
1430:	key = ksNext (ks);
1434:	key = ksNext (ks);
1438:	key = ksNext (ks);
1442:	key = ksNext (ks);
1446:	key = ksNext (ks);
1483:		ksRewind (returned);
1561: * 	ksCurrent() will tell you where it stopped.
1569:	elektraCursor cursor = ksGetCursor (ks);
1570:	ksRewind (ks);
1571:	while ((current = ksNext (ks)) != 0)
1577:	ksSetCursor (ks, cursor);
1586: * when it returns -1 the processing will be stopped. You can use ksCurrent()
1588: * apart from ksCurrent() the input will not be changed. The keys that have
1597: * @return -1 when filter returned an error (-1), ksCurrent() of input will
1606:	elektraCursor cursor = ksGetCursor (input);
1607:	ksRewind (input);
1608:	while ((current = ksNext (input)) != 0)
1619:	ksSetCursor (input, cursor);
1673:	ksRewind (ks);
1674:	while ((current = ksNext (ks)) != 0)
1714:	found = ksCurrent (values);
1733:	ksRewind (small);
1734:	ksNext (small);
1735:	succeed_if (ksCurrent (small) == a, "current not set correctly");
1741:	succeed_if (ksCurrent (small) == 0, "current not set correctly");
1744:	ksNext (small);
1745:	ksNext (small);
1746:	succeed_if (ksCurrent (small) == c, "current not set correctly");
1752:	succeed_if (ksCurrent (small) == 0, "current not set correctly");
1758:	succeed_if (ksCurrent (small) == 0, "current not set correctly");
1764:	succeed_if (ksCurrent (small) == 0, "current not set correctly");
1770:	succeed_if (ksCurrent (small) == 0, "current not set correctly");
1789:	succeed_if (ksCurrent (ks) == 0, "current not set correctly");
1791:	succeed_if (ksCurrent (ks) == 0, "current not set correctly");
1820:	succeed_if (ksCurrent (ks) == 0, "current not set correctly");
1822:	succeed_if (ksCurrent (ks) == 0, "current not set correctly");
1835:	succeed_if (ksCurrent (ks) == 0, "current not set correctly");
1843:	succeed_if (ksCurrent (ks) == 0, "current not set correctly");
1851:	succeed_if (ksCurrent (ks) == 0, "current not set correctly");
1859:	succeed_if (ksCurrent (ks) == 0, "current not set correctly");
1867:	succeed_if (ksCurrent (ks) == 0, "current not set correctly");
1876:	succeed_if (ksCurrent (ks) == 0, "current not set correctly");
1895:	ksRewind (ks1);
1896:	while ((cur = ksNext (ks1)) != 0)
1959:	succeed_if (ksCurrent (ks) == cur, "did not update current position");
1961:	succeed_if (ksCurrent (ks) == cur, "did not update current position");
1963:	succeed_if (ksCurrent (ks) == cur, "did not update current position");
1967:	succeed_if (ksCurrent (ks) == cur, "did not update current position (same key)");
1971:	succeed_if (ksCurrent (ks) == cur, "did not update current position (front key)");
1975:	succeed_if (ksCurrent (ks) == cur, "did not update current position (key in between)");
1982:	succeed_if (ksCurrent (ks) == cur, "did not update current position");
1986:	succeed_if (ksCurrent (ks) == cur, "did not update current position");
1990:	succeed_if (ksCurrent (ks) == cur, "did not update current position");
1994:	succeed_if (ksCurrent (ks) == cur, "did not update current position");
2001:	succeed_if (ksCurrent (ks) == newKey, "did not update current position");
2016:	succeed_if (ksCurrent (ks) == cur, "did not update current position");
2020:	succeed_if (ksCurrent (ks) == cur, "did not update current position");
2030:	ksNext (ks);
2031:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/test/test");
2032:	ksNext (ks);
2033:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/test/test/bar");
2034:	ksNext (ks);
2035:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/test/test/foo");
2036:	ksNext (ks);
2037:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/test/test-foo");
2050:	succeed_if (ksCurrent (ks) == 0, "not rewinded");
2051:	ksNext (ks);
2052:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/x");
2053:	ksNext (ks);
2054:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/x/%");
2055:	ksNext (ks);
2056:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/x/%/a");
2057:	ksNext (ks);
2058:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/x/%/b");
2059:	ksNext (ks);
2060:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/x/\\%");
2061:	ksNext (ks);
2062:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/x/\\%/a");
2063:	ksNext (ks);
2064:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/x/\\%/b");
2065:	ksNext (ks);
2066:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/x/%a");
2067:	ksNext (ks);
2068:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/x/%b");
2069:	ksNext (ks);
2070:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/x/A");
2071:	ksNext (ks);
2072:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/x/A/a");
2073:	ksNext (ks);
2074:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/x/A/b");
2075:	ksNext (ks);
2076:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/x/a\\/");
2077:	ksNext (ks);
2078:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/x/a\\/b");
2079:	ksNext (ks);
2080:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/x/a\\/b/a");
2081:	ksNext (ks);
2082:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/x/a\\/b/b");
2083:	ksNext (ks);
2084:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/x/aA");
2085:	ksNext (ks);
2086:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/x/aA/a");
2087:	ksNext (ks);
2088:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/x/aA/b");
2089:	ksNext (ks);
2090:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/x/aa");
2091:	ksNext (ks);
2092:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/x/aa/a");
2093:	ksNext (ks);
2094:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/x/aa/b");
2228:		ksRewind(orig); while ((key=ksNext(orig))!= 0) printf ("keyNew (\"%s\", KEY_END), ", keyName(key));
2232:		ksRewind(result); while ((key=ksNext(result))!= 0) printf ("keyNew (\"%s\", KEY_END), ", keyName(key));
2252:	ksRewind (orig);
2253:	ksNext (orig);
2254:	succeed_if_same_string (keyName (ksCurrent (orig)), "user:/a");
2255:	ksNext (orig);
2256:	succeed_if_same_string (keyName (ksCurrent (orig)), "user:/a/b");
2260:	succeed_if_same_string (keyName (ksCurrent (orig)), "user:/a/b");
2281:		ksRewind (orig);
2282:	ksNext (orig);
2283:	succeed_if_same_string (keyName (ksCurrent (orig)), "spec:/a");
2284:	ksNext (orig);
2285:	succeed_if_same_string (keyName (ksCurrent (orig)), "spec:/a/b");
2289:	succeed_if_same_string (keyName (ksCurrent (orig)), "spec:/a/b");
2334:		ksRewind (orig);
2335:	ksNext (orig);
2336:	succeed_if_same_string (keyName (ksCurrent (orig)), "spec:/a");
2337:	ksNext (orig);
2338:	succeed_if_same_string (keyName (ksCurrent (orig)), "spec:/a/b");
2343:	succeed_if (ksCurrent (orig) == 0, "empty keyset not rewinded");
2363:	ksRewind (orig);
2364:	ksNext (orig);
2365:	ksNext (orig);
2366:	succeed_if_same_string (keyName (ksCurrent (orig)), "user:/a");
2370:	succeed_if_same_string (keyName (ksCurrent (orig)), "dir:/a");
2395:	ksRewind (orig);
2396:	ksNext (orig);
2397:	succeed_if_same_string (keyName (ksCurrent (orig)), "user:/a");
2398:	ksNext (orig);
2399:	succeed_if_same_string (keyName (ksCurrent (orig)), "user:/a/b");
2400:	ksNext (orig);
2401:	succeed_if_same_string (keyName (ksCurrent (orig)), "user:/a/b/c");
2405:	succeed_if_same_string (keyName (ksCurrent (orig)), "user:/a/b");
2453:	ksRewind (orig);
2454:	ksNext (orig);
2455:	succeed_if_same_string (keyName (ksCurrent (orig)), "user:/export/a");
2457:	succeed_if_same_string (keyName (ksCurrent (orig)), "user:/export-backup/b");
2461:	succeed_if_same_string (keyName (ksCurrent (orig)), "user:/export-backup/b");
2485:	ksRewind (orig);
2486:	ksNext (orig);
2487:	succeed_if_same_string (keyName (ksCurrent (orig)), "/export/a");
2489:	succeed_if_same_string (keyName (ksCurrent (orig)), "/export-backup/b");
2493:	succeed_if_same_string (keyName (ksCurrent (orig)), "/export-backup/b");
2557:	succeed_if (ksGetCursor (config) == 1, "cursor not set correctly");
2559:	succeed_if (ksGetCursor (config) == 0, "cursor should stay as is");
2575:	succeed_if (ksGetCursor (0) == -1, "No error on NULL pointer");
2577:	ksRewind (config);
2578:	succeed_if (ksGetCursor (config) == -1, "should be invalid cursor");
2579:	succeed_if (ksNext (config) != 0, "should be root key");
2580:	succeed_if (ksGetCursor (config) == 0, "cursor on first position");
2581:	succeed_if_same_string (keyName (ksCurrent (config)), "system:/elektra/mountpoints/simple");
2582:	succeed_if (ksNext (config) != 0, "should be on config");
2583:	succeed_if (ksGetCursor (config) == 1, "cursor on config");
2584:	succeed_if_same_string (keyName (ksCurrent (config)), "system:/elektra/mountpoints/simple/config");
2586:	KeySet * res = ksCut (config, ksCurrent (config));
2587:	succeed_if (ksGetCursor (config) == 0, "cursor on first position");
2588:	succeed_if_same_string (keyName (ksCurrent (config)), "system:/elektra/mountpoints/simple");
2590:	succeed_if (ksNext (config) != 0, "should be on config");
2591:	succeed_if (ksGetCursor (config) == 1, "cursor on getplugins");
2592:	succeed_if_same_string (keyName (ksCurrent (config)), "system:/elektra/mountpoints/simple/getplugins");
2594:	KeySet * getplugins = ksCut (config, ksCurrent (config));
2595:	succeed_if (ksGetCursor (getplugins) == -1, "should be invalid cursor");
2596:	succeed_if (ksNext (getplugins) != 0, "should be root key");
2597:	succeed_if (ksGetCursor (getplugins) == 0, "cursor on first position");
2599:	succeed_if (ksNext (getplugins) != 0, "should be tracer");
2600:	succeed_if (ksGetCursor (getplugins) == 1, "cursor not correct");
2602:	KeySet * gettracer = ksCut (getplugins, ksCurrent (getplugins));
2603:	succeed_if (ksNext (getplugins) == 0, "should be no more getplugins");
2605:	succeed_if (ksNext (config) != 0, "next did not work");
2606:	succeed_if (ksGetCursor (config) == 1, "cursor not correct");
2607:	succeed_if_same_string (keyName (ksCurrent (config)), "system:/elektra/mountpoints/simple/mountpoint");
2609:	succeed_if (ksNext (config) != 0, "next did not work");
2610:	succeed_if (ksGetCursor (config) == 2, "cursor not correct");
2611:	succeed_if_same_string (keyName (ksCurrent (config)), "system:/elektra/mountpoints/simple/setplugins");
2613:	KeySet * setplugins = ksCut (config, ksCurrent (config));
2614:	succeed_if (ksNext (config) == 0, "should be no more config");
2615:	succeed_if (ksNext (setplugins) != 0, "ksnext did not work");
2616:	succeed_if_same_string (keyName (ksCurrent (setplugins)), "system:/elektra/mountpoints/simple/setplugins");
2617:	succeed_if (ksNext (setplugins) != 0, "ksnext did not work");
2619:	KeySet * settracer = ksCut (setplugins, ksCurrent (setplugins));
2620:	succeed_if (ksNext (setplugins) == 0, "should be no more setplugins");
2625:	succeed_if (ksSetCursor (0, 1) == -1, "No error on NULL keyset");
2626:	succeed_if (ksSetCursor (config, -1) == 0, "No error on invalid position");
2627:	succeed_if (ksSetCursor (config, 2) == 1, "Can not set cursor to KeySet");
2643:	succeed_if (ksCurrent (ks) == 0, "should be rewinded");
2644:	ksNext (ks);
2645:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/valid/key1");
2646:	ksNext (ks);
2647:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/valid/key2");
2648:	ksNext (ks);
2649:	succeed_if_same_string (keyName (ksCurrent (ks)), "system:/valid/key1");
2650:	ksNext (ks);
2651:	succeed_if_same_string (keyName (ksCurrent (ks)), "system:/valid/key2");
2678:	ksRewind (ks);
2679:	ksNext (ks);
2680:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/a/valid/key");
2681:	ksNext (ks);
2682:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/a/x/valid/key");
2683:	ksNext (ks);
2684:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/b/valid/key");
2685:	ksNext (ks);
2686:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/b/x/valid/key");
2687:	ksNext (ks);
2688:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/c/valid/key");
2689:	// printf ("%s\n", keyName(ksCurrent(ks)));
2698:	// printf ("%s\n", keyName(ksCurrent(ks)));
2699:	succeed_if_same_string (keyName (ksCurrent (ks)), "user:/c/valid/key");
2809:	ksRewind (ks2);
2810:	ksNext (ks2);
2811:	succeed_if_same_string (keyValue (keyGetMeta (ksCurrent (ks2), "hello")), "hello_world");
2812:	succeed_if (keyGetMeta (ksCurrent (ks2), "error") == 0, "hello was not set up to now");
2839:	ksRewind (iter);
2840:	Key * key = ksNext (iter);


   168	tests/abi/testabi_key.c:2
1610:	ksRewind (ks);
1611:	succeed_if_same_string (keyName (ksNext (ks)), "user:/orig");


   169	tests/abi/testabi_meta.c:15
69:	succeed_if (keyRewindMeta (0) == -1, "Could rewind NULL Key");
75:	succeed_if (keyCurrentMeta (0) == 0, "Could get current meta Key of NULL key");
76:	succeed_if (keyNextMeta (0) == 0, "Could get next meta Key of NULL key");
96:	succeed_if (keyRewindMeta (key) == 0, "Could not rewind empty key");
97:	succeed_if (keyNextMeta (key) == 0, "Could get next metaname, even if it is empty");
98:	succeed_if (keyCurrentMeta (key) == 0, "Could get next metavalue, even if it is empty");
101:	succeed_if (keyRewindMeta (key) == 0, "Could not rewind key");
102:	succeed_if_same_string (keyName (keyNextMeta (key)), "meta:/meta1");
103:	succeed_if_same_string (keyValue (keyCurrentMeta (key)), "meta_value");
105:	succeed_if (keyNextMeta (key) == 0, "Could get next metaname, even if it is empty at 2. iteration");
106:	succeed_if (keyCurrentMeta (key) == 0, "Could get next metavalue, even if it is empty at 2. iteration");
108:	succeed_if (keyNextMeta (key) == 0, "Could get next metaname, even if it is empty at 3. iteration");
109:	succeed_if (keyCurrentMeta (key) == 0, "Could get next metavalue, even if it is empty at 3. iteration");
111:	succeed_if (keyNextMeta (key) == 0, "Could get next metaname, even if it is empty at 4. iteration");
112:	succeed_if (keyCurrentMeta (key) == 0, "Could get next metavalue, even if it is empty at 4. iteration");


   170	tests/ctest/test_opts.c:4
116:	elektraCursor cursor = ksGetCursor (ks);
118:	ksRewind (ks);
120:	while ((cur = ksNext (ks)) != NULL)
126:	ksSetCursor (ks, cursor);


   171	tests/ctest/test_globbing.c:6
145:	ksRewind (expected);
146:	ksRewind (actual);
148:	Key * curA = ksNext (actual);
149:	Key * curE = ksNext (expected);
153:		curA = ksNext (actual);
154:		curE = ksNext (expected);

   
   172	tests/ctest/test_order.c:2
283:	ksRewind(ks);
284:	while ((it = ksNext(ks)) != 0)


   173	tests/ctest/test_ks_opmphm.c:6
53:		ksRewind (copy);
54:		while ((iter = ksNext (copy)))
86:		ksRewind (copy);
87:		while ((iter = ksNext (copy)))
119:		ksRewind (copy);
120:		while ((iter = ksNext (copy)))


   174	tests/ctest/test_meta.c:7
72:	cur = ksNext (ks);
74:	cur = ksNext (ks);
76:	cur = ksNext (ks);
90:		ksRewind (deps);
91:		ksNext (deps);
92:		ksRewind (done);
93:		while ((dep = ksNext (deps)) != NULL)


   175	tests/ctest/test_splitset.c:4
328:	ksRewind (ks);
329:	while ((key = ksNext (ks)) != 0)
381:	ksRewind (ks);
382:	while ((key = ksNext (ks)) != 0)


   176	tests/ctest/test_trie.c:4
152:	compare_key (ksHead (mps), mp);
153:	compare_key (ksTail (mps), mp2);
212:	compare_key (ksHead (mps), mp);
213:	compare_key (ksTail (mps), mp2);


   177	tests/ctest/test_ks.c:3
159:	ksNext (ks);
160:	elektraCursor cursor = ksGetCursor (ks);
163:	succeed_if (ksGetCursor (ks) == cursor, "cursor was not restored");


   178	tests/cframework/tests.h:9
312:			keyRewindMeta (mmk1);
313:			keyRewindMeta (mmk2);
314:			while ((meta = keyNextMeta (mmk1)) != 0)
316:				const Key * const metaCmp = keyNextMeta (mmk2);                      
343:			const Key * const metaCmp = keyNextMeta (mmk2);
388:				ksRewind (mmks1);
389:				ksRewind (mmks2);
391:				while ((cmmk1 = ksNext (mmks1)) != 0)
393:					cmmk2 = ksNext (mmks2);


   179	tests/cframework/tests.c:6
314:	ksRewind (ks);
315:	while ((k = ksNext (ks)) != 0)
323:	keyRewindMeta (k);
324:	while ((meta = keyNextMeta (k)) != 0)
341:	ksRewind (ks);
342:	while ((k = ksNext (ks)) != 0)






grep -cir -- "ksRewind\|ksNext\|ksCurrent\|ksGetCursor\|ksSetCursor\|keyRewindMeta\|keyNextMeta\|keyCurrentMeta\|ksHead\|ksTail" * | grep -v ':0$' | nl


